# Prompt 1.3 : Cr√©ation de la base de donn√©es# Prompt 1.3 : Cr√©ation de la base de donn√©es



## Contexte global## Contexte global

PyCalendar V2 transforme une application CLI/Excel d'optimisation de calendriers sportifs en application web full-stack. L'architecture pr√©serve totalement le code existant (solvers/, constraints/, generators/, validation/) et ajoute une couche backend (FastAPI, SQLAlchemy, SQLite) + frontend (React, TypeScript, FullCalendar).PyCalendar V2 transforme une application CLI/Excel d'optimisation de calendriers sportifs en application web full-stack. L'architecture pr√©serve totalement le code existant (solvers/, constraints/, generators/, validation/) et ajoute une couche backend (FastAPI, SQLAlchemy, SQLite) + frontend (React, TypeScript, FullCalendar). La base de donn√©es SQLite persiste les projets, √©quipes, gymnases et matchs avec gestion des relations, foreign keys et indexes pour optimiser les requ√™tes API.



**IMPORTANT - Double configuration du syst√®me actuel** :## Contexte technique

1. **Fichier YAML** (ex: `configs/default.yaml`, `configs/config_volley.yaml`)Cette t√¢che cr√©e l'infrastructure de persistance avec SQLAlchemy : l'engine SQLite, la session factory, et les 4 mod√®les principaux (Project, Team, Venue, Match) avec leurs relations (ForeignKey, cascade delete) et propri√©t√©s calcul√©es. Les mod√®les DB reproduisent la logique m√©tier des dataclasses `core/models.py` enrichies pr√©c√©demment.

   - Hyperparam√®tres : poids contraintes, strat√©gie solver, temps max, nb_semaines

   - R√©f√©rence le fichier Excel via `fichiers.donnees`## R√©sum√© du travail pr√©c√©dent

   - Charg√© par `core/config.py` (class `Config`)- Le mod√®le m√©tier `core/models.py` contient les dataclasses avec les nouveaux champs (`Match.est_fixe`, `Match.statut`, scores) - T√¢che 1.1

- La dataclass `Config` contient `semaine_min` pour contrainte de planification - T√¢che 1.2

2. **Fichier Excel** (ex: `config_exemple.xlsx`, `config_volley.xlsx`)- Le CLI et les g√©n√©rateurs fonctionnent avec ces mod√®les enrichis

   - Donn√©es d√©taill√©es avec **7+ feuilles** :- Les besoins de persistance et d'API REST sont identifi√©s

     - `Equipes` : Liste des √©quipes avec poule, horaire pr√©f√©r√©

     - `Gymnases` : Gymnases avec cr√©neaux disponibles et capacit√©## Objectifs

     - `Indispos_Gymnases` : Indisponibilit√©s des gymnases1. Cr√©er l'engine SQLAlchemy avec SQLite et support des foreign keys

     - `Indispos_Equipes` : Indisponibilit√©s par √©quipe2. D√©finir les 4 mod√®les SQLAlchemy (Project, Team, Venue, Match) mappant les entit√©s du projet

     - `Indispos_Institutions` : Indisponibilit√©s par institution (appliqu√©es √† toutes les √©quipes)3. Mettre en place les relations (ForeignKey, cascade delete) et les indexes pour optimisation

     - `Preferences_Gymnases` : Classement des gymnases pr√©f√©r√©s par institution4. Reproduire la logique m√©tier (propri√©t√©s `est_planifie`, `est_modifiable`) dans les mod√®les DB

     - `Obligation_Presence` : Gymnases n√©cessitant la pr√©sence d'une institution5. Cr√©er les fonctions utilitaires (`get_db()`, `init_db()`) pour l'API FastAPI

     - (+ autres feuilles optionnelles : Ententes, Contraintes_Temporelles, Groupes_Non_Simultaneite, etc.)

   - Charg√© par `core/config_manager.py` (class `ConfigManager`)## D√©tails techniques

   - **Script crucial** : `actualiser_config.py` valide et corrige la structure Excel

### Sous-t√¢che 1.3.1 : Engine et Session Factory

La base de donn√©es SQLite persiste les projets, √©quipes, gymnases et matchs avec gestion des relations, foreign keys et indexes pour optimiser les requ√™tes API.

**üìÅ Fichier √† cr√©er** : `backend/database/engine.py`

## Contexte technique

Cette t√¢che cr√©e l'infrastructure de persistance avec SQLAlchemy : l'engine SQLite, la session factory, et les 4 mod√®les principaux (Project, Team, Venue, Match) avec leurs relations (ForeignKey, cascade delete) et propri√©t√©s calcul√©es. Les mod√®les DB reproduisent la logique m√©tier des dataclasses `core/models.py` enrichies pr√©c√©demment.**Imports requis** :

```python

**Point crucial** : La base de donn√©es web dupliquera les donn√©es du fichier Excel (import initial), puis √©voluera de mani√®re ind√©pendante (modifications via UI, matchs fixes, scores, etc.). Le fichier Excel reste la source initiale de v√©rit√©.from sqlalchemy import create_engine, event

from sqlalchemy.orm import sessionmaker

## R√©sum√© du travail pr√©c√©dentfrom pathlib import Path

- Le mod√®le m√©tier `core/models.py` contient les dataclasses avec les nouveaux champs (`Match.est_fixe`, `Match.statut`, scores) - T√¢che 1.1```

- La dataclass `Config` (YAML) contient `semaine_minimum` pour contrainte de planification - T√¢che 1.2

- Le `ConfigManager` (Excel) charge les donn√©es d√©taill√©es (√©quipes, gymnases, indispos, pr√©f√©rences)**Contenu d√©taill√©** :

- Le CLI et les g√©n√©rateurs fonctionnent avec ces mod√®les enrichis

- `actualiser_config.py` valide la structure des fichiers Excel```python

from sqlalchemy import create_engine, event

## Objectifsfrom sqlalchemy.orm import sessionmaker

1. Cr√©er l'engine SQLAlchemy avec SQLite et support des foreign keysfrom pathlib import Path

2. D√©finir les 4 mod√®les SQLAlchemy (Project, Team, Venue, Match) mappant les entit√©s du projet

3. Mettre en place les relations (ForeignKey, cascade delete) et les indexes pour optimisation# Chemin vers la base de donn√©es SQLite

4. Reproduire la logique m√©tier (propri√©t√©s `est_planifie`, `est_modifiable`) dans les mod√®les DBBASE_DIR = Path(__file__).resolve().parent.parent.parent  # Racine du projet

5. Cr√©er les fonctions utilitaires (`get_db()`, `init_db()`) pour l'API FastAPIDATABASE_PATH = BASE_DIR / "database" / "pycalendar.db"

6. **Pr√©voir le stockage des donn√©es Excel ET des configurations YAML** dans la DBDATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)  # Cr√©er dossier si inexistant



## D√©tails techniques# URL de connexion SQLite

DATABASE_URL = f"sqlite:///{DATABASE_PATH}"

### Sous-t√¢che 1.3.1 : Engine et Session Factory

# Cr√©er l'engine SQLAlchemy

**üìÅ Fichier √† cr√©er** : `backend/database/engine.py`engine = create_engine(

    DATABASE_URL,

**Imports requis** :    connect_args={"check_same_thread": False},  # N√©cessaire pour FastAPI avec SQLite

```python    echo=False  # Mettre True pour debug SQL

from sqlalchemy import create_engine, event)

from sqlalchemy.orm import sessionmaker

from pathlib import Path# Activer les foreign keys SQLite (CRUCIAL - d√©sactiv√©es par d√©faut)

```@event.listens_for(engine, "connect")

def set_sqlite_pragma(dbapi_conn, connection_record):

**Contenu d√©taill√©** :    cursor = dbapi_conn.cursor()

    cursor.execute("PRAGMA foreign_keys=ON")

```python    cursor.close()

from sqlalchemy import create_engine, event

from sqlalchemy.orm import sessionmaker# Session factory

from pathlib import PathSessionLocal = sessionmaker(

    autocommit=False,

# Chemin vers la base de donn√©es SQLite    autoflush=False,

BASE_DIR = Path(__file__).resolve().parent.parent.parent  # Racine du projet    bind=engine

DATABASE_PATH = BASE_DIR / "database" / "pycalendar.db")

DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)  # Cr√©er dossier si inexistant

# Dependency injection pour FastAPI

# URL de connexion SQLitedef get_db():

DATABASE_URL = f"sqlite:///{DATABASE_PATH}"    """Generator pour cr√©er une session DB, l'utiliser, puis la fermer"""

    db = SessionLocal()

# Cr√©er l'engine SQLAlchemy    try:

engine = create_engine(        yield db

    DATABASE_URL,    finally:

    connect_args={"check_same_thread": False},  # N√©cessaire pour FastAPI avec SQLite        db.close()

    echo=False  # Mettre True pour debug SQL

)# Fonction d'initialisation de la DB

def init_db():

# Activer les foreign keys SQLite (CRUCIAL - d√©sactiv√©es par d√©faut)    """Cr√©er toutes les tables d√©finies dans models.py"""

@event.listens_for(engine, "connect")    from backend.database.models import Base  # Import ici pour √©viter circular import

def set_sqlite_pragma(dbapi_conn, connection_record):    Base.metadata.create_all(bind=engine)

    cursor = dbapi_conn.cursor()    print(f"‚úÖ Base de donn√©es cr√©√©e : {DATABASE_PATH}")

    cursor.execute("PRAGMA foreign_keys=ON")```

    cursor.close()

**Points cl√©s** :

# Session factory- **Chemin DB** : `database/pycalendar.db` √† la racine du projet (cr√©√© automatiquement)

SessionLocal = sessionmaker(- **PRAGMA foreign_keys** : MUST √™tre activ√© √† chaque connexion (d√©sactiv√© par d√©faut dans SQLite)

    autocommit=False,- **check_same_thread=False** : N√©cessaire pour FastAPI (multi-threading)

    autoflush=False,- **get_db()** : Generator pour dependency injection FastAPI (`Depends(get_db)`)

    bind=engine- **init_db()** : Cr√©er toutes les tables (appeler depuis script d'initialisation)

)

---

# Dependency injection pour FastAPI

def get_db():### Sous-t√¢che 1.3.2 : Mod√®les SQLAlchemy

    """Generator pour cr√©er une session DB, l'utiliser, puis la fermer"""

    db = SessionLocal()**üìÅ Fichier √† cr√©er** : `backend/database/models.py`

    try:

        yield db**Imports requis** :

    finally:```python

        db.close()from sqlalchemy import Column, Integer, String, Boolean, Text, JSON, DateTime, ForeignKey, Index

from sqlalchemy.ext.declarative import declarative_base

# Fonction d'initialisation de la DBfrom sqlalchemy.orm import relationship

def init_db():from datetime import datetime

    """Cr√©er toutes les tables d√©finies dans models.py"""```

    from backend.database.models import Base  # Import ici pour √©viter circular import

    Base.metadata.create_all(bind=engine)**Base declarative** :

    print(f"‚úÖ Base de donn√©es cr√©√©e : {DATABASE_PATH}")```python

```Base = declarative_base()

```

**Points cl√©s** :

- **Chemin DB** : `database/pycalendar.db` √† la racine du projet (cr√©√© automatiquement)---

- **PRAGMA foreign_keys** : MUST √™tre activ√© √† chaque connexion (d√©sactiv√© par d√©faut dans SQLite)

- **check_same_thread=False** : N√©cessaire pour FastAPI (multi-threading)#### Model 1 : Project

- **get_db()** : Generator pour dependency injection FastAPI (`Depends(get_db)`)

- **init_db()** : Cr√©er toutes les tables (appeler depuis script d'initialisation)```python

class Project(Base):

---    __tablename__ = "projects"

    

### Sous-t√¢che 1.3.2 : Mod√®les SQLAlchemy    # Cl√© primaire

    id = Column(Integer, primary_key=True, autoincrement=True)

**üìÅ Fichier √† cr√©er** : `backend/database/models.py`    

    # Informations projet

**Imports requis** :    nom = Column(String(200), nullable=False)

```python    sport = Column(String(50), nullable=False)

from sqlalchemy import Column, Integer, String, Boolean, Text, JSON, DateTime, ForeignKey, Index    

from sqlalchemy.ext.declarative import declarative_base    # Configuration

from sqlalchemy.orm import relationship    config_yaml_path = Column(String(500), nullable=True)

from datetime import datetime    config_data = Column(JSON, nullable=True)  # Stockage config compl√®te en JSON

```    

    # Param√®tres planification

**Base declarative** :    nb_semaines = Column(Integer, default=26, nullable=False)

```python    semaine_min = Column(Integer, default=1, nullable=False)  # NOUVEAU (T√¢che 1.2)

Base = declarative_base()    

```    # Timestamps

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

---    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    

#### Model 1 : Project    # Relations (cascade delete pour supprimer matchs/√©quipes/gymnases si projet supprim√©)

    matches = relationship("Match", back_populates="project", cascade="all, delete-orphan")

```python    teams = relationship("Team", back_populates="project", cascade="all, delete-orphan")

class Project(Base):    venues = relationship("Venue", back_populates="project", cascade="all, delete-orphan")

    __tablename__ = "projects"```

    

    # Cl√© primaire**Points cl√©s** :

    id = Column(Integer, primary_key=True, autoincrement=True)- `config_data` : JSON pour stocker toute la config (√©quipes, gymnases, cr√©neaux)

    - `semaine_min` : Reproduit le champ ajout√© dans `core.Config` (T√¢che 1.2)

    # Informations projet- **Cascade delete** : Supprimer un projet supprime tous ses matchs/√©quipes/gymnases

    nom = Column(String(200), nullable=False)

    sport = Column(String(50), nullable=False)---

    

    # Chemins des fichiers de configuration (optionnels)#### Model 2 : Team

    config_yaml_path = Column(String(500), nullable=True)  # Chemin du fichier YAML (ex: configs/config_volley.yaml)

    config_excel_path = Column(String(500), nullable=True)  # Chemin du fichier Excel (ex: donnees/config_volley.xlsx)```python

    class Team(Base):

    # Stockage des configurations compl√®tes (JSON)    __tablename__ = "teams"

    config_yaml_data = Column(JSON, nullable=True)  # Contenu complet du YAML (hyperparam√®tres)    

    config_excel_data = Column(JSON, nullable=True)  # R√©sum√© ou m√©tadonn√©es Excel (nom feuilles, stats, etc.)    # Cl√© primaire

        id = Column(Integer, primary_key=True, autoincrement=True)

    # Param√®tres planification (dupliqu√©s depuis YAML pour acc√®s rapide)    

    nb_semaines = Column(Integer, default=26, nullable=False)    # Foreign key

    semaine_min = Column(Integer, default=1, nullable=False)  # De "semaine_minimum" dans YAML    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)

        

    # Timestamps    # Informations √©quipe

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)    nom = Column(String(200), nullable=False)

    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)    institution = Column(String(200), nullable=True)

        numero_equipe = Column(String(50), nullable=True)

    # Relations (cascade delete pour supprimer matchs/√©quipes/gymnases si projet supprim√©)    genre = Column(String(20), nullable=True)

    matches = relationship("Match", back_populates="project", cascade="all, delete-orphan")    poule = Column(String(100), nullable=True)

    teams = relationship("Team", back_populates="project", cascade="all, delete-orphan")    

    venues = relationship("Venue", back_populates="project", cascade="all, delete-orphan")    # Pr√©f√©rences (JSON arrays)

```    horaires_preferes = Column(JSON, nullable=True)  # ["Mercredi 14h", "Vendredi 18h"]

    lieux_preferes = Column(JSON, nullable=True)     # ["Gymnase A", "Gymnase B"]

**Points cl√©s** :    

- **Stockage double config** :    # Timestamp

  - `config_yaml_path` + `config_yaml_data` : R√©f√©rence et contenu du YAML    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

  - `config_excel_path` + `config_excel_data` : R√©f√©rence et m√©tadonn√©es Excel    

- `semaine_min` : Reproduit `semaine_minimum` du YAML (T√¢che 1.2)    # Relation

- **Cascade delete** : Supprimer un projet supprime tous ses matchs/√©quipes/gymnases    project = relationship("Project", back_populates="teams")

```

---

**Points cl√©s** :

#### Model 2 : Team- **ForeignKey avec CASCADE** : Supprimer projet ‚Üí supprimer √©quipes

- **Index sur project_id** : Optimiser requ√™tes `GET /teams/?project_id=X`

```python- **JSON pour listes** : horaires_preferes, lieux_preferes

class Team(Base):

    __tablename__ = "teams"---

    

    # Cl√© primaire#### Model 3 : Venue

    id = Column(Integer, primary_key=True, autoincrement=True)

    ```python

    # Foreign keyclass Venue(Base):

    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)    __tablename__ = "venues"

        

    # Informations √©quipe (depuis feuille Excel "Equipes")    # Cl√© primaire

    nom = Column(String(200), nullable=False)  # Colonne "Equipe"    id = Column(Integer, primary_key=True, autoincrement=True)

    institution = Column(String(200), nullable=True)  # Extraite du nom (ex: "CENTRALE" de "CENTRALE 1 (1)")    

    numero_equipe = Column(String(50), nullable=True)  # Num√©ro apr√®s institution (ex: "1" de "CENTRALE 1")    # Foreign key

    genre = Column(String(20), nullable=True)  # Extrait de la poule (ex: "M" de "HBFA1PK")    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)

    poule = Column(String(100), nullable=True)  # Colonne "Poule" du Excel    

        # Informations gymnase

    # Pr√©f√©rences (JSON arrays - depuis Excel ou calcul√©es)    nom = Column(String(200), nullable=False)

    horaires_preferes = Column(JSON, nullable=True)  # ["Mercredi 14h", "Vendredi 18h"] - depuis "Horaire_Prefere"    capacite = Column(Integer, default=1, nullable=False)  # Nombre de terrains simultan√©s

    lieux_preferes = Column(JSON, nullable=True)     # ["Gymnase A", "Gymnase B"] - depuis feuille "Preferences_Gymnases"    

        # Disponibilit√©s (JSON array)

    # Timestamp    horaires_disponibles = Column(JSON, nullable=True)  # ["Mercredi 14h", "Mercredi 16h", ...]

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)    

        # Timestamp

    # Relation    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    project = relationship("Project", back_populates="teams")    

```    # Relation

    project = relationship("Project", back_populates="venues")

**Points cl√©s** :```

- **Source Excel** : Feuille `Equipes` (colonnes: Equipe, Poule, Horaire_Prefere)

- **Institution/num√©ro** : Extraits du nom (ex: "CENTRALE 1 (1)" ‚Üí institution="CENTRALE", numero="1")**Points cl√©s** :

- **Pr√©f√©rences** : `lieux_preferes` vient de la feuille `Preferences_Gymnases` (par institution)- `capacite` : Nombre de matchs simultan√©s possibles dans le gymnase

- **Index sur project_id** : Optimiser requ√™tes `GET /teams/?project_id=X`- **JSON pour disponibilit√©s** : horaires_disponibles

- **JSON pour listes** : horaires_preferes, lieux_preferes

---

---

#### Model 4 : Match

#### Model 3 : Venue

```python

```pythonclass Match(Base):

class Venue(Base):    __tablename__ = "matches"

    __tablename__ = "venues"    

        # Cl√© primaire

    # Cl√© primaire    id = Column(Integer, primary_key=True, autoincrement=True)

    id = Column(Integer, primary_key=True, autoincrement=True)    

        # Foreign key

    # Foreign key    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)

    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)    

        # √âquipes (d√©normalis√© pour simplifier les requ√™tes)

    # Informations gymnase (depuis feuille Excel "Gymnases")    equipe1_nom = Column(String(200), nullable=False)

    nom = Column(String(200), nullable=False)  # Colonne "Gymnase"    equipe1_institution = Column(String(200), nullable=True)

    capacite = Column(Integer, default=1, nullable=False)  # Colonne "Capacite" (nombre de terrains simultan√©s)    equipe1_genre = Column(String(20), nullable=True)

        

    # Disponibilit√©s (JSON array - depuis colonnes horaires du Excel)    equipe2_nom = Column(String(200), nullable=False)

    horaires_disponibles = Column(JSON, nullable=True)  # ["Mercredi 14h", "Mercredi 16h", ...] - colonnes "Mercredi 14:00", etc.    equipe2_institution = Column(String(200), nullable=True)

        equipe2_genre = Column(String(20), nullable=True)

    # Timestamp    

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)    # Poule

        poule = Column(String(100), nullable=True, index=True)  # Index pour filtrage

    # Relation    

    project = relationship("Project", back_populates="venues")    # Cr√©neau (nullable si non planifi√©)

```    semaine = Column(Integer, nullable=True, index=True)  # Index pour filtrage par semaine

    horaire = Column(String(20), nullable=True)  # "Mercredi 14h"

**Points cl√©s** :    gymnase = Column(String(200), nullable=True)

- **Source Excel** : Feuille `Gymnases` (colonnes: Gymnase, Capacite, + horaires en colonnes dynamiques)    

- `capacite` : Nombre de matchs simultan√©s possibles    # √âtat (NOUVEAUX CHAMPS - T√¢che 1.1)

- **horaires_disponibles** : Cr√©neaux extraits des colonnes Excel (ex: si "Mercredi 14:00" = 1, ajouter √† la liste)    est_fixe = Column(Boolean, default=False, nullable=False, index=True)  # Index pour filtrage

- **JSON pour disponibilit√©s**    statut = Column(String(50), default="a_planifier", nullable=False, index=True)  # Index pour filtrage

    priorite = Column(Integer, default=0, nullable=False)

---    

    # Scores (NOUVEAUX CHAMPS - T√¢che 1.1)

#### Model 4 : Match    score_equipe1 = Column(Integer, nullable=True)

    score_equipe2 = Column(Integer, nullable=True)

```python    

class Match(Base):    # Notes (NOUVEAU CHAMP - T√¢che 1.1)

    __tablename__ = "matches"    notes = Column(Text, nullable=True)

        

    # Cl√© primaire    # Timestamps

    id = Column(Integer, primary_key=True, autoincrement=True)    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

        updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    # Foreign key    

    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)    # Relation

        project = relationship("Project", back_populates="matches")

    # √âquipes (d√©normalis√© pour simplifier les requ√™tes)    

    equipe1_nom = Column(String(200), nullable=False)    # Properties calcul√©es (reproduire logique core.Match - T√¢che 1.1)

    equipe1_institution = Column(String(200), nullable=True)    @property

    equipe1_genre = Column(String(20), nullable=True)    def est_planifie(self) -> bool:

            """Retourne True si le match a un cr√©neau assign√©"""

    equipe2_nom = Column(String(200), nullable=False)        return self.semaine is not None

    equipe2_institution = Column(String(200), nullable=True)    

    equipe2_genre = Column(String(20), nullable=True)    @property

        def est_modifiable(self) -> bool:

    # Poule        """Retourne True si le match peut √™tre replanifi√©"""

    poule = Column(String(100), nullable=True, index=True)  # Index pour filtrage        if self.est_fixe:

                return False

    # Cr√©neau (nullable si non planifi√©)        if self.statut in ["fixe", "termine", "annule"]:

    semaine = Column(Integer, nullable=True, index=True)  # Index pour filtrage par semaine            return False

    horaire = Column(String(20), nullable=True)  # "Mercredi 14h"        return True

    gymnase = Column(String(200), nullable=True)```

    

    # √âtat (NOUVEAUX CHAMPS - T√¢che 1.1)**Points cl√©s** :

    est_fixe = Column(Boolean, default=False, nullable=False, index=True)  # Verrouill√© (non replanifiable)- **D√©normalisation √©quipes** : Stocker nom/institution/genre directement (pas de FK vers Team)

    statut = Column(String(50), default="a_planifier", nullable=False, index=True)  # a_planifier, planifie, fixe, termine, annule- **Indexes multiples** : project_id, poule, semaine, est_fixe, statut pour optimiser requ√™tes API

    priorite = Column(Integer, default=0, nullable=False)- **Properties** : Reproduisent exactement la logique de `core.Match` (T√¢che 1.1)

    - **Nouveaux champs** : est_fixe, statut, scores, notes (ajout√©s T√¢che 1.1)

    # Scores (NOUVEAUX CHAMPS - T√¢che 1.1)

    score_equipe1 = Column(Integer, nullable=True)---

    score_equipe2 = Column(Integer, nullable=True)

    #### Indexes Composites (Ajouter en fin de fichier)

    # Notes (NOUVEAU CHAMP - T√¢che 1.1)

    notes = Column(Text, nullable=True)```python

    # Indexes composites pour optimiser les requ√™tes fr√©quentes

    # TimestampsIndex('idx_match_project_semaine', Match.project_id, Match.semaine)

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)Index('idx_match_project_poule', Match.project_id, Match.poule)

    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)```

    

    # Relation**Usage** :

    project = relationship("Project", back_populates="matches")- `idx_match_project_semaine` : Optimiser `GET /matches/?project_id=1&semaine=5`

    - `idx_match_project_poule` : Optimiser `GET /matches/?project_id=1&poule=A`

    # Properties calcul√©es (reproduire logique core.Match - T√¢che 1.1)

    @property---

    def est_planifie(self) -> bool:

        """Retourne True si le match a un cr√©neau assign√©"""### Structure compl√®te attendue du fichier models.py

        return self.semaine is not None

    ```python

    @propertyfrom sqlalchemy import Column, Integer, String, Boolean, Text, JSON, DateTime, ForeignKey, Index

    def est_modifiable(self) -> bool:from sqlalchemy.ext.declarative import declarative_base

        """Retourne True si le match peut √™tre replanifi√©"""from sqlalchemy.orm import relationship

        if self.est_fixe:from datetime import datetime

            return False

        if self.statut in ["fixe", "termine", "annule"]:Base = declarative_base()

            return False

        return Trueclass Project(Base):

```    # ... (voir ci-dessus)



**Points cl√©s** :class Team(Base):

- **Source initiale** : Matchs g√©n√©r√©s par `generators/match_generator.py` (round-robin depuis feuille Equipes)    # ... (voir ci-dessus)

- **D√©normalisation √©quipes** : Stocker nom/institution/genre directement (pas de FK vers Team)

- **Indexes multiples** : project_id, poule, semaine, est_fixe, statut pour optimiser requ√™tes APIclass Venue(Base):

- **Properties** : Reproduisent exactement la logique de `core.Match` (T√¢che 1.1)    # ... (voir ci-dessus)

- **Nouveaux champs** : est_fixe, statut, scores, notes (ajout√©s T√¢che 1.1)

class Match(Base):

---    # ... (voir ci-dessus)



#### Indexes Composites (Ajouter en fin de fichier)# Indexes composites

Index('idx_match_project_semaine', Match.project_id, Match.semaine)

```pythonIndex('idx_match_project_poule', Match.project_id, Match.poule)

# Indexes composites pour optimiser les requ√™tes fr√©quentes```

Index('idx_match_project_semaine', Match.project_id, Match.semaine)

Index('idx_match_project_poule', Match.project_id, Match.poule)---

```

### Impact et liens avec autres modules

**Usage** :

- `idx_match_project_semaine` : Optimiser `GET /matches/?project_id=1&semaine=5`**Int√©gration avec engine.py** :

- `idx_match_project_poule` : Optimiser `GET /matches/?project_id=1&poule=A`- `init_db()` dans `engine.py` importe `Base` et appelle `Base.metadata.create_all()`

- `get_db()` fournit les sessions pour les routes API (T√¢che 1.5)

---

**Int√©gration future avec schemas Pydantic** :

### Impact et liens avec autres modules- `backend/schemas/match.py` (T√¢che 1.4) : Schemas Pydantic miroirs pour s√©rialisation API

- Config `from_attributes=True` dans schemas pour conversion ORM ‚Üí Pydantic

**Int√©gration avec engine.py** :

- `init_db()` dans `engine.py` importe `Base` et appelle `Base.metadata.create_all()`**Int√©gration future avec API Routes** :

- `get_db()` fournit les sessions pour les routes API (T√¢che 1.5)- `backend/api/routes/matches.py` (T√¢che 1.5) : Utilise ces mod√®les pour CRUD

- Exemple : `db.query(Match).filter(Match.project_id == project_id).all()`

**Int√©gration future avec schemas Pydantic** :

- `backend/schemas/match.py` (T√¢che 1.4) : Schemas Pydantic miroirs pour s√©rialisation API**Int√©gration future avec Service de Sync** :

- Config `from_attributes=True` dans schemas pour conversion ORM ‚Üí Pydantic- `backend/services/sync_service.py` (T√¢che 1.6) : Convertit Excel ‚Üí instances de ces mod√®les

- Exemple : `Project(nom=..., sport=...)`, `Match(equipe1_nom=..., ...)`

**Int√©gration future avec Service de Sync** :

- `backend/services/sync_service.py` (T√¢che 1.6) : **Convertit YAML + Excel ‚Üí instances de ces mod√®les**### Consignes d'organisation

  - Charge YAML via `Config.from_yaml()`- **Ordre des mod√®les** : Project d'abord, puis Team/Venue, puis Match (d√©pendances FK)

  - Charge Excel via `ConfigManager(fichier_excel)`- **Indexes** : Ajouter sur colonnes utilis√©es dans filtres API (project_id, semaine, poule, statut, est_fixe)

  - Cr√©e `Project` avec chemins YAML/Excel et donn√©es JSON- **Cascade delete** : TOUJOURS sur relations parent‚Üíenfant pour √©viter orphelins

  - Cr√©e `Team` depuis feuille Equipes- **Properties vs m√©thodes** : Utiliser `@property` pour calculs simples sans arguments

  - Cr√©e `Venue` depuis feuille Gymnases

  - Cr√©e `Match` via g√©n√©rateurs (round-robin)## √Ä faire/v√©rifier



**Int√©gration future avec actualiser_config.py** :**Checklist de d√©veloppement** :

- `actualiser_config.py` valide la structure Excel AVANT import

- Pourrait √™tre appel√© automatiquement par le service de sync**engine.py** :

- D√©tecte colonnes manquantes, renomme colonnes mal nomm√©es, valide le contenu1. ‚úÖ Cr√©er fichier `backend/database/engine.py`

2. ‚úÖ D√©finir `DATABASE_PATH = BASE_DIR / "database" / "pycalendar.db"`

### Consignes d'organisation3. ‚úÖ Cr√©er engine avec `check_same_thread=False`

- **Ordre des mod√®les** : Project d'abord, puis Team/Venue, puis Match (d√©pendances FK)4. ‚úÖ Activer foreign keys via `@event.listens_for(engine, "connect")`

- **Indexes** : Ajouter sur colonnes utilis√©es dans filtres API (project_id, semaine, poule, statut, est_fixe)5. ‚úÖ Cr√©er `SessionLocal` avec `autocommit=False, autoflush=False`

- **Cascade delete** : TOUJOURS sur relations parent‚Üíenfant pour √©viter orphelins6. ‚úÖ Impl√©menter `get_db()` generator avec try/finally

- **Properties vs m√©thodes** : Utiliser `@property` pour calculs simples sans arguments7. ‚úÖ Impl√©menter `init_db()` avec import `Base` et `create_all()`

- **Stockage config** : Pr√©voir chemins + donn√©es JSON pour YAML et Excel

**models.py** :

## √Ä faire/v√©rifier1. ‚úÖ Cr√©er fichier `backend/database/models.py`

2. ‚úÖ D√©finir `Base = declarative_base()`

**Checklist de d√©veloppement** :3. ‚úÖ Cr√©er mod√®le `Project` avec tous les champs + relations cascade

4. ‚úÖ Cr√©er mod√®le `Team` avec FK + index + relation

**engine.py** :5. ‚úÖ Cr√©er mod√®le `Venue` avec FK + index + relation

1. ‚úÖ Cr√©er fichier `backend/database/engine.py`6. ‚úÖ Cr√©er mod√®le `Match` avec tous les champs + properties

2. ‚úÖ D√©finir `DATABASE_PATH = BASE_DIR / "database" / "pycalendar.db"`7. ‚úÖ Ajouter indexes composites en fin de fichier

3. ‚úÖ Cr√©er engine avec `check_same_thread=False`

4. ‚úÖ Activer foreign keys via `@event.listens_for(engine, "connect")`**Checklist de validation** :

5. ‚úÖ Cr√©er `SessionLocal` avec `autocommit=False, autoflush=False`

6. ‚úÖ Impl√©menter `get_db()` generator avec try/finally1. ‚úÖ Importer les mod√®les sans erreur :

7. ‚úÖ Impl√©menter `init_db()` avec import `Base` et `create_all()`   ```python

   from backend.database.models import Base, Project, Team, Venue, Match

**models.py** :   print(Base.metadata.tables.keys())  # Doit afficher: dict_keys(['projects', 'teams', 'venues', 'matches'])

1. ‚úÖ Cr√©er fichier `backend/database/models.py`   ```

2. ‚úÖ D√©finir `Base = declarative_base()`

3. ‚úÖ Cr√©er mod√®le `Project` avec chemins config + donn√©es JSON + relations cascade2. ‚úÖ Cr√©er la base de donn√©es :

4. ‚úÖ Cr√©er mod√®le `Team` avec source Excel document√©e + FK + index + relation   ```python

5. ‚úÖ Cr√©er mod√®le `Venue` avec source Excel document√©e + FK + index + relation   from backend.database.engine import init_db

6. ‚úÖ Cr√©er mod√®le `Match` avec tous les champs + properties   init_db()  # Doit cr√©er database/pycalendar.db

7. ‚úÖ Ajouter indexes composites en fin de fichier   ```



**Checklist de validation** :3. ‚úÖ V√©rifier les tables cr√©√©es :

   ```bash

1. ‚úÖ Importer les mod√®les sans erreur :   sqlite3 database/pycalendar.db ".tables"

   ```python   # Doit afficher: matches  projects  teams  venues

   from backend.database.models import Base, Project, Team, Venue, Match   ```

   print(Base.metadata.tables.keys())  # Doit afficher: dict_keys(['projects', 'teams', 'venues', 'matches'])

   ```4. ‚úÖ V√©rifier le sch√©ma d'une table :

   ```bash

2. ‚úÖ Cr√©er la base de donn√©es :   sqlite3 database/pycalendar.db ".schema matches"

   ```python   # Doit afficher les colonnes, FK, indexes

   from backend.database.engine import init_db   ```

   init_db()  # Doit cr√©er database/pycalendar.db

   ```5. ‚úÖ Tester les foreign keys :

   ```python

3. ‚úÖ V√©rifier les tables cr√©√©es :   from backend.database.engine import SessionLocal, init_db

   ```bash   from backend.database.models import Project, Match

   sqlite3 database/pycalendar.db ".tables"   

   # Doit afficher: matches  projects  teams  venues   init_db()

   ```   db = SessionLocal()

   

4. ‚úÖ V√©rifier le sch√©ma d'une table :   # Cr√©er projet

   ```bash   p = Project(nom="Test", sport="Volley")

   sqlite3 database/pycalendar.db ".schema projects"   db.add(p)

   # Doit afficher config_yaml_path, config_excel_path, config_yaml_data, config_excel_data, semaine_min, etc.   db.commit()

   ```   db.refresh(p)

   

5. ‚úÖ Tester les foreign keys :   # Cr√©er match

   ```python   m = Match(project_id=p.id, equipe1_nom="A", equipe2_nom="B", poule="Poule 1")

   from backend.database.engine import SessionLocal, init_db   db.add(m)

   from backend.database.models import Project, Match   db.commit()

      

   init_db()   # V√©rifier relation

   db = SessionLocal()   assert len(p.matches) == 1

      assert m.project.nom == "Test"

   # Cr√©er projet   

   p = Project(nom="Test Volley", sport="Volley", config_yaml_path="configs/test.yaml")   # Tester cascade delete

   db.add(p)   db.delete(p)

   db.commit()   db.commit()

   db.refresh(p)   assert db.query(Match).count() == 0  # Match supprim√© aussi

      

   # Cr√©er match   db.close()

   m = Match(project_id=p.id, equipe1_nom="A", equipe2_nom="B", poule="Poule 1")   ```

   db.add(m)

   db.commit()6. ‚úÖ Tester les properties :

      ```python

   # V√©rifier relation   from backend.database.models import Match

   assert len(p.matches) == 1   

   assert m.project.nom == "Test Volley"   # Match non planifi√©

      m1 = Match(equipe1_nom="A", equipe2_nom="B", poule="P1")

   # Tester cascade delete   assert m1.est_planifie == False

   db.delete(p)   assert m1.est_modifiable == True

   db.commit()   

   assert db.query(Match).count() == 0  # Match supprim√© aussi   # Match planifi√©

      m2 = Match(equipe1_nom="A", equipe2_nom="B", poule="P1", semaine=5)

   db.close()   assert m2.est_planifie == True

   ```   

   # Match fixe

6. ‚úÖ Tester les properties :   m3 = Match(equipe1_nom="A", equipe2_nom="B", poule="P1", est_fixe=True)

   ```python   assert m3.est_modifiable == False

   from backend.database.models import Match   ```

   

   # Match non planifi√©**Commandes de test** :

   m1 = Match(equipe1_nom="A", equipe2_nom="B", poule="P1")```bash

   assert m1.est_planifie == False# Cr√©er DB

   assert m1.est_modifiable == Truepython -c "from backend.database.engine import init_db; init_db()"

   

   # Match planifi√©# V√©rifier tables

   m2 = Match(equipe1_nom="A", equipe2_nom="B", poule="P1", semaine=5)sqlite3 database/pycalendar.db ".tables"

   assert m2.est_planifie == True

   # V√©rifier sch√©ma

   # Match fixesqlite3 database/pycalendar.db ".schema matches"

   m3 = Match(equipe1_nom="A", equipe2_nom="B", poule="P1", est_fixe=True)

   assert m3.est_modifiable == False# Tester foreign keys

   ```sqlite3 database/pycalendar.db "PRAGMA foreign_keys; INSERT INTO matches (project_id, equipe1_nom, equipe2_nom, poule) VALUES (999, 'A', 'B', 'P1');"

# Doit √©chouer avec "FOREIGN KEY constraint failed"

**Commandes de test** :```

```bash

# Cr√©er DB## Questions

python -c "from backend.database.engine import init_db; init_db()"- Faut-il ajouter une contrainte CHECK sur `semaine_min <= nb_semaines` dans le mod√®le Project ?

- Faut-il valider les valeurs de `statut` avec un ENUM SQLite ou laisser libre ?

# V√©rifier tables- Faut-il ajouter un index sur `Match.gymnase` pour optimiser les requ√™tes par lieu ?

sqlite3 database/pycalendar.db ".tables"- Faut-il stocker les √©quipes normalis√©es (FK vers Team) ou garder d√©normalis√© (plus simple pour l'affichage) ?



# V√©rifier sch√©ma Project (doit avoir config_yaml_path, config_excel_path, etc.)## Documentation

sqlite3 database/pycalendar.db ".schema projects"Rester concis : documenter uniquement les choix techniques non √©vidents (ex: d√©normalisation √©quipes, pourquoi cascade delete, pourquoi indexes composites). √âviter la sur-documentation des concepts SQLAlchemy standards.


# Tester foreign keys
sqlite3 database/pycalendar.db "PRAGMA foreign_keys; INSERT INTO matches (project_id, equipe1_nom, equipe2_nom, poule) VALUES (999, 'A', 'B', 'P1');"
# Doit √©chouer avec "FOREIGN KEY constraint failed"
```

## Questions

**Questions critiques √† poser si quelque chose n'est pas clair** :

1. **Structure des feuilles Excel** :
   - Quelles sont les colonnes exactes de chaque feuille (Equipes, Gymnases, etc.) ?
   - Comment extraire institution/num√©ro depuis le nom d'√©quipe ? (ex: regex, split, etc.)
   - Faut-il stocker TOUTES les feuilles Excel en JSON ou seulement un r√©sum√© ?

2. **Gestion de la configuration** :
   - Faut-il dupliquer `nb_semaines` dans Project (depuis YAML) ou le recalculer √† chaque fois ?
   - Le champ s'appelle `semaine_minimum` dans YAML et `semaine_min` dans DB : est-ce OK ?

3. **Import Excel ‚Üí DB** :
   - Faut-il valider avec `actualiser_config.py` AVANT d'importer dans la DB ?
   - Que faire si le fichier Excel est invalide (colonnes manquantes, etc.) ?

4. **√âvolution des donn√©es** :
   - Une fois import√©, le fichier Excel peut-il √™tre re-synchronis√© (√©crasement DB) ?
   - Ou la DB devient-elle la source de v√©rit√© (Excel seulement pour import initial) ?

5. **Matchs fixes** :
   - Les matchs fixes sont-ils d√©finis dans une feuille Excel ou uniquement via l'UI web ?
   - Si Excel : quelle feuille ? Quelles colonnes ?

6. **Validation** :
   - Faut-il ajouter des contraintes CHECK SQL (ex: `semaine_min <= nb_semaines`) ?
   - Faut-il valider les valeurs de `statut` avec un ENUM ou laisser libre ?

---

## Documentation

Rester concis : documenter uniquement les choix techniques non √©vidents :
- **Pourquoi d√©normalisation √©quipes** : Simplifier affichage et requ√™tes (pas de JOIN)
- **Pourquoi cascade delete** : √âviter orphelins (supprimer projet = supprimer tout)
- **Pourquoi indexes composites** : Optimiser filtres API fr√©quents (project+semaine, project+poule)
- **Pourquoi stocker config YAML/Excel** : Tra√ßabilit√© et possibilit√© de r√©-export
- **Lien avec actualiser_config.py** : Valider Excel avant import pour √©viter erreurs

√âviter la sur-documentation des concepts SQLAlchemy standards.
