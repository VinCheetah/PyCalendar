# Prompt 1.4 : Sch√©mas Pydantic pour l'API# Prompt 1.4 : Sch√©mas Pydantic pour l'API



## Contexte global## Contexte global

PyCalendar V2 expose une API REST pour la gestion des projets, √©quipes, gymnases et matchs. Les sch√©mas Pydantic assurent la validation des donn√©es entrantes et la s√©rialisation des r√©ponses, en coh√©rence avec les mod√®les SQLAlchemy.PyCalendar V2 expose une API REST pour la gestion des projets, √©quipes, gymnases et matchs. Les sch√©mas Pydantic assurent la validation des donn√©es entrantes et la s√©rialisation des r√©ponses, en coh√©rence avec les mod√®les SQLAlchemy.



**RAPPEL - Double configuration** :## Contexte technique

- **Fichier YAML** : Hyperparam√®tres (charg√© par `core/config.py`)Cette t√¢che concerne la d√©finition des sch√©mas Pydantic pour chaque entit√© (Match, Project, Team, Venue), en respectant le pattern Base/Create/Update/Response et en assurant la correspondance avec les mod√®les de base de donn√©es.

- **Fichier Excel** : Donn√©es d√©taill√©es avec feuilles Equipes, Gymnases, etc. (charg√© par `core/config_manager.py`)

- **Base de donn√©es** : Stocke les donn√©es import√©es depuis YAML+Excel, puis √©volue ind√©pendamment## R√©sum√© du travail pr√©c√©dent

- Les mod√®les SQLAlchemy sont en place (`backend/database/models.py`) avec toutes les relations.

## Contexte technique- Le mod√®le m√©tier (`core/models.py`) d√©finit la logique des matchs.

Cette t√¢che d√©finit les sch√©mas Pydantic pour chaque entit√© (Match, Project, Team, Venue), en respectant le pattern Base/Create/Update/Response et en assurant la correspondance avec les mod√®les SQLAlchemy cr√©√©s en T√¢che 1.3.- Les besoins d'√©change de donn√©es via API REST sont identifi√©s.



## R√©sum√© du travail pr√©c√©dent## Objectifs

- Les mod√®les SQLAlchemy sont en place (`backend/database/models.py`) avec toutes les relations - T√¢che 1.3- D√©finir des sch√©mas Pydantic clairs et complets pour chaque entit√©.

- Le model Project stocke les chemins et donn√©es des configs YAML+Excel- S'assurer de la coh√©rence entre sch√©mas, mod√®les SQLAlchemy et logique m√©tier.

- Le mod√®le m√©tier (`core/models.py`) d√©finit la logique des matchs avec champs enrichis - T√¢che 1.1- Pr√©voir l'extensibilit√© des sch√©mas pour de futurs champs.

- Les besoins d'√©change de donn√©es via API REST sont identifi√©s

## D√©tails techniques

## Objectifs

1. D√©finir des sch√©mas Pydantic clairs et complets pour chaque entit√©### Sous-t√¢che 1 : Schemas Match

2. Assurer la correspondance exacte avec les mod√®les SQLAlchemy (T√¢che 1.3)**Fichier √† cr√©er** : `backend/schemas/match.py`

3. Supporter la double configuration (YAML + Excel) dans les sch√©mas

4. Pr√©voir l'extensibilit√© des sch√©mas pour de futurs champs**Sch√©mas requis** :



## D√©tails techniques1. **MatchBase** (BaseModel Pydantic) :

   - Champs : equipe1_nom, equipe1_institution, equipe1_genre, equipe2_nom, equipe2_institution, equipe2_genre

### Sous-t√¢che 1.4.1 : Schemas Match   - poule, semaine (Optional[int]), horaire (Optional[str]), gymnase (Optional[str])

   - est_fixe (bool = False), statut (str = "a_planifier"), priorite (int = 0)

**üìÅ Fichier √† cr√©er** : `backend/schemas/match.py`   - Valeurs par d√©faut identiques au model DB



**Imports requis** :2. **MatchCreate** (h√©rite MatchBase) :

```python   - Ajouter : `project_id: int`

from pydantic import BaseModel, ConfigDict

from typing import Optional3. **MatchUpdate** (BaseModel) :

from datetime import datetime   - Tous champs optionnels : semaine, horaire, gymnase, est_fixe, statut, priorite, score_equipe1, score_equipe2, notes

```   - Permet updates partiels



**Sch√©mas requis** :4. **MatchResponse** (h√©rite MatchBase) :

   - Ajouter : id, project_id, score_equipe1, score_equipe2, notes, created_at, updated_at

**1. MatchBase** (sch√©ma de base commun) :   - Config : `from_attributes = True` (pour conversion depuis ORM)

```python

class MatchBase(BaseModel):5. **MatchMove** (BaseModel) :

    # √âquipes (d√©normalis√©es - depuis mod√®le DB)   - Champs : semaine (int), horaire (str), gymnase (str)

    equipe1_nom: str   - Pour endpoint de d√©placement drag & drop

    equipe1_institution: Optional[str] = None

    equipe1_genre: Optional[str] = None### Sous-t√¢che 2 : Schemas Project

    **Fichier √† cr√©er** : `backend/schemas/project.py`

    equipe2_nom: str

    equipe2_institution: Optional[str] = None**Sch√©mas requis** :

    equipe2_genre: Optional[str] = None- **ProjectBase** : nom, sport, config_yaml_path (Optional), nb_semaines (int = 26), semaine_min (int = 1)

    - **ProjectCreate** (h√©rite ProjectBase)

    # Poule- **ProjectUpdate** : tous champs optionnels

    poule: Optional[str] = None- **ProjectResponse** : ajouter id, config_data (Optional), created_at, updated_at, avec `from_attributes = True`

    

    # Cr√©neau (optionnel si non planifi√©)### Sous-t√¢che 3 : Schemas Team

    semaine: Optional[int] = None**Fichier √† cr√©er** : `backend/schemas/team.py`

    horaire: Optional[str] = None

    gymnase: Optional[str] = None**Sch√©mas requis** :

    - **TeamBase** : nom, institution, numero_equipe (Optional), genre, poule, horaires_preferes (List[str]), lieux_preferes (List[str])

    # √âtat (valeurs par d√©faut identiques au model DB)- **TeamCreate** : ajouter project_id

    est_fixe: bool = False- **TeamUpdate** : tous champs optionnels

    statut: str = "a_planifier"- **TeamResponse** : ajouter id, project_id, created_at, avec `from_attributes = True`

    priorite: int = 0

```### Sous-t√¢che 4 : Schemas Venue

**Fichier √† cr√©er** : `backend/schemas/venue.py`

**2. MatchCreate** (cr√©ation d'un match) :

```python**Sch√©mas requis** :

class MatchCreate(MatchBase):- **VenueBase** : nom, capacite (int = 1), horaires_disponibles (List[str])

    project_id: int  # R√©f√©rence au projet- **VenueCreate** : ajouter project_id

```- **VenueUpdate** : tous champs optionnels

- **VenueResponse** : ajouter id, project_id, created_at, avec `from_attributes = True`

**3. MatchUpdate** (mise √† jour partielle) :

```python### Consignes d'organisation

class MatchUpdate(BaseModel):- Utiliser `Optional[T]` pour champs nullables

    # Tous champs optionnels pour updates partiels- Import `datetime` pour typage timestamps

    semaine: Optional[int] = None- Import `List` de `typing` pour listes

    horaire: Optional[str] = None- Config `from_attributes = True` n√©cessaire pour r√©ponses ORM

    gymnase: Optional[str] = None- Valider la correspondance avec les mod√®les SQLAlchemy

    est_fixe: Optional[bool] = None

    statut: Optional[str] = None### Impact et liens

    priorite: Optional[int] = None- Les routes API (`backend/api/routes/`) utiliseront ces sch√©mas pour validation/s√©rialisation.

    score_equipe1: Optional[int] = None- Les mod√®les SQLAlchemy (`backend/database/models.py`) seront convertis via `from_attributes`.

    score_equipe2: Optional[int] = None- Le service de synchronisation (`backend/services/sync_service.py`) cr√©era des instances compatibles.

    notes: Optional[str] = None

```## √Ä faire/v√©rifier

- Proposer la structure de chaque sch√©ma (Base, Create, Update, Response)

**4. MatchResponse** (r√©ponse API) :- V√©rifier la correspondance avec les mod√®les SQLAlchemy

```python- S'assurer que la validation est stricte mais extensible

class MatchResponse(MatchBase):- Tester la s√©rialisation : `MatchResponse.model_validate(match_orm_instance)`

    id: int

    project_id: int## Questions

    Poser des questions si des points sur la structure, la validation ou la correspondance avec les mod√®les ne sont pas clairs.

    # Scores et notes (ajout√©s T√¢che 1.1)

    score_equipe1: Optional[int] = None## Documentation

    score_equipe2: Optional[int] = NoneRester concis, ne pas ajouter de documentation excessive. Commenter bri√®vement les sch√©mas si besoin pour clarifier leur usage.

    notes: Optional[str] = None
    
    # Timestamps
    created_at: datetime
    updated_at: datetime
    
    model_config = ConfigDict(from_attributes=True)  # Pour conversion ORM ‚Üí Pydantic
```

**5. MatchMove** (d√©placement drag & drop) :
```python
class MatchMove(BaseModel):
    semaine: int
    horaire: str
    gymnase: str
```

**Points cl√©s** :
- `from_attributes=True` (Pydantic V2) permet conversion directe depuis mod√®le SQLAlchemy
- Valeurs par d√©faut identiques au mod√®le DB (coh√©rence)
- `MatchUpdate` : tous champs optionnels pour PATCH partiel

---

### Sous-t√¢che 1.4.2 : Schemas Project

**üìÅ Fichier √† cr√©er** : `backend/schemas/project.py`

**Imports requis** :
```python
from pydantic import BaseModel, ConfigDict
from typing import Optional, Dict, Any
from datetime import datetime
```

**Sch√©mas requis** :

**1. ProjectBase** :
```python
class ProjectBase(BaseModel):
    nom: str
    sport: str
    
    # Chemins des fichiers de configuration (optionnels)
    config_yaml_path: Optional[str] = None
    config_excel_path: Optional[str] = None
    
    # Param√®tres planification (depuis YAML)
    nb_semaines: int = 26
    semaine_min: int = 1  # De "semaine_minimum" dans YAML
```

**2. ProjectCreate** :
```python
class ProjectCreate(ProjectBase):
    # Donn√©es compl√®tes optionnelles (JSON)
    config_yaml_data: Optional[Dict[str, Any]] = None
    config_excel_data: Optional[Dict[str, Any]] = None
```

**3. ProjectUpdate** :
```python
class ProjectUpdate(BaseModel):
    # Tous champs optionnels pour updates partiels
    nom: Optional[str] = None
    sport: Optional[str] = None
    config_yaml_path: Optional[str] = None
    config_excel_path: Optional[str] = None
    config_yaml_data: Optional[Dict[str, Any]] = None
    config_excel_data: Optional[Dict[str, Any]] = None
    nb_semaines: Optional[int] = None
    semaine_min: Optional[int] = None
```

**4. ProjectResponse** :
```python
class ProjectResponse(ProjectBase):
    id: int
    
    # Donn√©es JSON (optionnelles)
    config_yaml_data: Optional[Dict[str, Any]] = None
    config_excel_data: Optional[Dict[str, Any]] = None
    
    # Timestamps
    created_at: datetime
    updated_at: datetime
    
    model_config = ConfigDict(from_attributes=True)
```

**5. ProjectStats** (statistiques) :
```python
class ProjectStats(BaseModel):
    """Statistiques d'un projet"""
    nb_matchs_total: int
    nb_matchs_planifies: int
    nb_matchs_fixes: int
    nb_matchs_a_planifier: int
    nb_equipes: int
    nb_gymnases: int
```

**Points cl√©s** :
- `config_yaml_data` et `config_excel_data` : Stockage JSON complet des configurations
- `semaine_min` : Reproduit `semaine_minimum` du YAML (coh√©rence avec DB)
- `ProjectStats` : Sch√©ma sp√©cifique pour endpoint statistiques

---

### Sous-t√¢che 1.4.3 : Schemas Team

**üìÅ Fichier √† cr√©er** : `backend/schemas/team.py`

**Imports requis** :
```python
from pydantic import BaseModel, ConfigDict
from typing import Optional, List
from datetime import datetime
```

**Sch√©mas requis** :

**1. TeamBase** :
```python
class TeamBase(BaseModel):
    # Informations √©quipe (depuis feuille Excel "Equipes")
    nom: str
    institution: Optional[str] = None
    numero_equipe: Optional[str] = None
    genre: Optional[str] = None
    poule: Optional[str] = None
    
    # Pr√©f√©rences (depuis Excel ou calcul√©es)
    horaires_preferes: Optional[List[str]] = None  # Depuis "Horaire_Prefere"
    lieux_preferes: Optional[List[str]] = None     # Depuis feuille "Preferences_Gymnases"
```

**2. TeamCreate** :
```python
class TeamCreate(TeamBase):
    project_id: int
```

**3. TeamUpdate** :
```python
class TeamUpdate(BaseModel):
    # Tous champs optionnels
    nom: Optional[str] = None
    institution: Optional[str] = None
    numero_equipe: Optional[str] = None
    genre: Optional[str] = None
    poule: Optional[str] = None
    horaires_preferes: Optional[List[str]] = None
    lieux_preferes: Optional[List[str]] = None
```

**4. TeamResponse** :
```python
class TeamResponse(TeamBase):
    id: int
    project_id: int
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)
```

**Points cl√©s** :
- Source Excel document√©e en commentaires (Equipes, Preferences_Gymnases)
- Listes JSON pour horaires_preferes et lieux_preferes

---

### Sous-t√¢che 1.4.4 : Schemas Venue

**üìÅ Fichier √† cr√©er** : `backend/schemas/venue.py`

**Imports requis** :
```python
from pydantic import BaseModel, ConfigDict
from typing import Optional, List
from datetime import datetime
```

**Sch√©mas requis** :

**1. VenueBase** :
```python
class VenueBase(BaseModel):
    # Informations gymnase (depuis feuille Excel "Gymnases")
    nom: str
    capacite: int = 1  # Nombre de terrains simultan√©s
    
    # Disponibilit√©s (depuis colonnes horaires du Excel)
    horaires_disponibles: Optional[List[str]] = None
```

**2. VenueCreate** :
```python
class VenueCreate(VenueBase):
    project_id: int
```

**3. VenueUpdate** :
```python
class VenueUpdate(BaseModel):
    # Tous champs optionnels
    nom: Optional[str] = None
    capacite: Optional[int] = None
    horaires_disponibles: Optional[List[str]] = None
```

**4. VenueResponse** :
```python
class VenueResponse(VenueBase):
    id: int
    project_id: int
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)
```

**Points cl√©s** :
- Source Excel document√©e (feuille Gymnases)
- `capacite` : Nombre de matchs simultan√©s possibles

---

### Consignes d'organisation

**Pattern commun pour tous les sch√©mas** :
1. **Base** : Champs communs create/response
2. **Create** : Base + project_id (+ donn√©es optionnelles pour Project)
3. **Update** : Tous champs optionnels (PATCH partiel)
4. **Response** : Base + id, timestamps, `from_attributes=True`

**Imports** :
- `Optional[T]` pour champs nullables
- `List[T]` pour listes (horaires, pr√©f√©rences)
- `Dict[str, Any]` pour JSON (config_data)
- `datetime` pour timestamps
- `ConfigDict(from_attributes=True)` pour conversion ORM

**Validation** :
- Pydantic valide automatiquement les types
- Utiliser `Field()` si validation personnalis√©e n√©cessaire (ex: `semaine_min >= 1`)

---

### Impact et liens avec autres modules

**Utilisation par les routes API** (T√¢che 1.5) :
```python
# backend/api/routes/matches.py
from backend.schemas.match import MatchCreate, MatchUpdate, MatchResponse

@router.post("/", response_model=MatchResponse, status_code=201)
def create_match(match: MatchCreate, db: Session = Depends(get_db)):
    # Validation automatique par Pydantic
    db_match = Match(**match.model_dump())
    # ...
```

**Conversion ORM ‚Üí Pydantic** (automatique avec `from_attributes`) :
```python
# backend/api/routes/matches.py
@router.get("/{match_id}", response_model=MatchResponse)
def get_match(match_id: int, db: Session = Depends(get_db)):
    match = db.query(Match).filter(Match.id == match_id).first()
    return match  # Conversion automatique Match (ORM) ‚Üí MatchResponse (Pydantic)
```

**Utilisation par le service de sync** (T√¢che 1.6) :
```python
# backend/services/sync_service.py
from backend.schemas.project import ProjectCreate

def import_from_excel(yaml_path: str, excel_path: str) -> int:
    # Cr√©er projet avec sch√©ma
    project_data = ProjectCreate(
        nom="Volley 2025",
        sport="Volley",
        config_yaml_path=yaml_path,
        config_excel_path=excel_path,
        config_yaml_data=yaml_content,
        nb_semaines=26,
        semaine_min=1
    )
    # ...
```

---

## √Ä faire/v√©rifier

**Checklist de d√©veloppement** :

1. ‚úÖ Cr√©er `backend/schemas/match.py` avec 5 sch√©mas (Base, Create, Update, Response, Move)
2. ‚úÖ Cr√©er `backend/schemas/project.py` avec 5 sch√©mas (Base, Create, Update, Response, Stats)
3. ‚úÖ Cr√©er `backend/schemas/team.py` avec 4 sch√©mas (Base, Create, Update, Response)
4. ‚úÖ Cr√©er `backend/schemas/venue.py` avec 4 sch√©mas (Base, Create, Update, Response)
5. ‚úÖ V√©rifier correspondance exacte avec mod√®les SQLAlchemy (T√¢che 1.3)
6. ‚úÖ Documenter sources Excel en commentaires (Equipes, Gymnases, Preferences_Gymnases)

**Checklist de validation** :

1. ‚úÖ Importer les sch√©mas sans erreur :
   ```python
   from backend.schemas.match import MatchCreate, MatchUpdate, MatchResponse, MatchMove
   from backend.schemas.project import ProjectCreate, ProjectResponse, ProjectStats
   from backend.schemas.team import TeamCreate, TeamResponse
   from backend.schemas.venue import VenueCreate, VenueResponse
   ```

2. ‚úÖ Tester la validation Pydantic :
   ```python
   from backend.schemas.match import MatchCreate
   
   # Valide
   match_data = MatchCreate(
       project_id=1,
       equipe1_nom="Equipe A",
       equipe2_nom="Equipe B",
       poule="Poule 1"
   )
   assert match_data.est_fixe == False
   assert match_data.statut == "a_planifier"
   
   # Invalide (manque equipe1_nom)
   try:
       MatchCreate(project_id=1, equipe2_nom="B")
   except ValidationError:
       print("Validation OK : equipe1_nom requis")
   ```

3. ‚úÖ Tester la conversion ORM ‚Üí Pydantic :
   ```python
   from backend.database.models import Match
   from backend.schemas.match import MatchResponse
   
   # Cr√©er un match ORM
   match_orm = Match(
       id=1,
       project_id=1,
       equipe1_nom="A",
       equipe2_nom="B",
       poule="P1",
       semaine=5,
       created_at=datetime.utcnow(),
       updated_at=datetime.utcnow()
   )
   
   # Conversion automatique
   match_response = MatchResponse.model_validate(match_orm)
   assert match_response.id == 1
   assert match_response.semaine == 5
   ```

4. ‚úÖ Tester les updates partiels :
   ```python
   from backend.schemas.match import MatchUpdate
   
   # Update partiel (seulement semaine et horaire)
   update_data = MatchUpdate(semaine=10, horaire="Mercredi 14h")
   update_dict = update_data.model_dump(exclude_unset=True)
   assert update_dict == {"semaine": 10, "horaire": "Mercredi 14h"}
   ```

**Commandes de test** :
```bash
# V√©rifier imports
python -c "from backend.schemas import match, project, team, venue; print('‚úÖ Tous les sch√©mas import√©s')"

# Tester validation
python -c "
from backend.schemas.match import MatchCreate
m = MatchCreate(project_id=1, equipe1_nom='A', equipe2_nom='B', poule='P1')
print(f'Match cr√©√© : {m.equipe1_nom} vs {m.equipe2_nom}')
"
```

---

## Questions

**Questions critiques √† poser si quelque chose n'est pas clair** :

1. **Validation des valeurs** :
   - Faut-il valider les valeurs de `statut` (ex: enum avec ["a_planifier", "planifie", "fixe", "termine", "annule"]) ?
   - Faut-il valider `semaine_min <= nb_semaines` dans ProjectCreate ?
   - Faut-il valider `capacite >= 1` dans VenueCreate ?

2. **Correspondance DB** :
   - Les noms de champs correspondent-ils exactement aux colonnes SQLAlchemy ?
   - Le nom `semaine_min` (schema) vs `semaine_minimum` (YAML) est-il OK ?

3. **Donn√©es JSON** :
   - Quel format exact pour `config_yaml_data` et `config_excel_data` ?
   - Faut-il d√©finir des sous-sch√©mas pour ces JSON ou laisser Dict[str, Any] ?

4. **Listes vides** :
   - `horaires_preferes: Optional[List[str]] = None` ou `List[str] = []` (liste vide par d√©faut) ?
   - M√™me question pour `lieux_preferes` et `horaires_disponibles` ?

5. **ProjectStats** :
   - Quels autres champs statistiques seraient utiles ?
   - Faut-il ajouter des pourcentages (ex: `pct_planifies = nb_planifies / nb_total`) ?

---

## Documentation

Rester concis : documenter uniquement les choix non √©vidents :
- **Source des donn√©es** : Commentaires indiquant quelle feuille Excel (ex: `# Depuis feuille "Equipes"`)
- **Conversion ORM** : Expliquer `from_attributes=True` une fois (permet Match ORM ‚Üí MatchResponse)
- **Updates partiels** : Expliquer pourquoi tous champs optionnels dans Update (PATCH partiel)
- **Pattern Base/Create/Update/Response** : Documenter une fois la logique commune

√âviter la sur-documentation des concepts Pydantic standards.
