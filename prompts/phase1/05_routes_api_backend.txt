# Prompt 1.5 : Routes API Backend# Prompt 1.5 : Routes API ‚Äì Backend



## Contexte global## Contexte global

PyCalendar V2 expose une API REST pour manipuler les projets, √©quipes, gymnases et matchs. L'API FastAPI doit √™tre claire, coh√©rente, s√©curis√©e et facilement extensible, avec support CORS pour le frontend React.PyCalendar V2 expose une API REST pour manipuler les projets, √©quipes, gymnases et matchs. L'API FastAPI doit √™tre claire, coh√©rente, s√©curis√©e et facilement extensible, avec support CORS pour le frontend React.



**RAPPEL - Double configuration** :## Contexte technique

- **Fichier YAML** : Hyperparam√®tres (charg√© par `core/config.py`)Cette t√¢che concerne la cr√©ation de l'application FastAPI principale et des routes pour chaque entit√©, en respectant les bonnes pratiques REST et la logique m√©tier (gestion des matchs fixes, d√©placement, fixation/d√©fixation).

- **Fichier Excel** : Donn√©es d√©taill√©es (charg√© par `core/config_manager.py`)

- **Import initial** : Service de sync (T√¢che 1.6) charge YAML+Excel ‚Üí DB## R√©sum√© du travail pr√©c√©dent

- **√âvolution** : Donn√©es DB modifi√©es via API, ind√©pendamment des fichiers source- Les mod√®les SQLAlchemy et sch√©mas Pydantic sont d√©finis.

- L'engine et la session factory sont en place (`backend/database/engine.py`).

## Contexte technique- Les besoins en termes d'op√©rations CRUD et de gestion sp√©cifique des matchs sont connus.

Cette t√¢che cr√©e l'application FastAPI principale et les routes pour chaque entit√©, en respectant les bonnes pratiques REST et la logique m√©tier (gestion des matchs fixes, d√©placement, fixation/d√©fixation).

## Objectifs

## R√©sum√© du travail pr√©c√©dent- Cr√©er l'application FastAPI avec CORS configur√© pour le frontend.

- Les mod√®les SQLAlchemy sont d√©finis avec stockage config YAML+Excel (`backend/database/models.py`) - T√¢che 1.3- D√©finir les routes n√©cessaires pour chaque entit√© (CRUD, actions sp√©cifiques).

- Les sch√©mas Pydantic sont cr√©√©s pour validation/s√©rialisation (`backend/schemas/`) - T√¢che 1.4- S'assurer de la coh√©rence, de la s√©curit√© et de l'extensibilit√© des endpoints.

- L'engine et la session factory sont en place (`backend/database/engine.py`) - T√¢che 1.3

- La logique m√©tier (matchs fixes, statuts) est d√©finie - T√¢che 1.1## D√©tails techniques



## Objectifs### Sous-t√¢che 1 : Application FastAPI

1. Cr√©er l'application FastAPI avec CORS configur√© pour le frontend**Fichier √† cr√©er** : `backend/api/main.py`

2. D√©finir les routes CRUD pour chaque entit√© (Projects, Teams, Venues, Matches)

3. Impl√©menter les actions sp√©cifiques aux matchs (move, fix, unfix)**√âl√©ments requis** :

4. Assurer coh√©rence, validation et gestion d'erreurs- Cr√©er app : `FastAPI(title="PyCalendar API", version="2.0.0")`

- Middleware CORS :

## D√©tails techniques  - `allow_origins=["http://localhost:5173"]` (frontend dev)

  - `allow_credentials=True`

### Sous-t√¢che 1.5.1 : Application FastAPI  - `allow_methods=["*"]`, `allow_headers=["*"]`

- Routes basiques :

**üìÅ Fichier √† cr√©er** : `backend/api/main.py`  - `GET /` ‚Üí info API (titre, version, description)

  - `GET /health` ‚Üí status check {"status": "ok"}

**Imports requis** :- Import routers (√† d√©commenter apr√®s cr√©ation) :

```python  - `from backend.api.routes import matches, projects, teams, venues`

from fastapi import FastAPI  - `app.include_router(matches.router, prefix="/matches", tags=["Matches"])`

from fastapi.middleware.cors import CORSMiddleware  - Idem pour projects, teams, venues

```

### Sous-t√¢che 2 : Routes Matches

**Contenu d√©taill√©** :**Fichier √† cr√©er** : `backend/api/routes/matches.py`



```python**Router** : `router = APIRouter()`

from fastapi import FastAPI

from fastapi.middleware.cors import CORSMiddleware**Imports critiques** :

- `from backend.database.engine import get_db`

# Cr√©er l'application FastAPI- `from backend.database import models`

app = FastAPI(- `from backend.schemas import match as schemas`

    title="PyCalendar API",- `from fastapi import Depends, HTTPException, status`

    version="2.0.0",

    description="API REST pour la gestion de calendriers sportifs"**Endpoints requis** :

)

1. **GET /matches/** :

# Configuration CORS pour frontend React (dev)   - Query param optionnel : `project_id: Optional[int] = None`

app.add_middleware(   - Filtrer par projet si fourni, sinon tous les matchs

    CORSMiddleware,   - Response : `List[schemas.MatchResponse]`

    allow_origins=["http://localhost:5173"],  # Frontend Vite dev server

    allow_credentials=True,2. **GET /matches/{match_id}** :

    allow_methods=["*"],  # GET, POST, PUT, DELETE, PATCH, OPTIONS   - R√©cup√©rer match par ID

    allow_headers=["*"],  # Authorization, Content-Type, etc.   - HTTPException 404 si non trouv√©

)   - Response : `schemas.MatchResponse`



# Routes basiques3. **POST /matches/** :

@app.get("/")   - Body : `schemas.MatchCreate`

def root():   - Cr√©er en DB, commit, refresh

    """Page d'accueil de l'API"""   - Status code 201

    return {   - Response : `schemas.MatchResponse`

        "title": "PyCalendar API",

        "version": "2.0.0",4. **PUT /matches/{match_id}** :

        "description": "API REST pour la gestion de calendriers sportifs",   - Body : `schemas.MatchUpdate`

        "docs": "/docs",   - Utiliser `.model_dump(exclude_unset=True)` pour update partiel

        "redoc": "/redoc"   - It√©rer et setattr sur model

    }   - Commit, refresh

   - Response : `schemas.MatchResponse`

@app.get("/health")

def health_check():5. **POST /matches/{match_id}/move** :

    """Health check endpoint"""   - Body : `schemas.MatchMove`

    return {"status": "ok"}   - **V√©rifier** `match.est_modifiable` avant update

   - HTTPException 400 si match fix√©

# Import et inclusion des routers (d√©commenter apr√®s cr√©ation des fichiers)   - Update semaine/horaire/gymnase

# from backend.api.routes import matches, projects, teams, venues   - Changer statut √† "planifie"

#    - Commit, refresh

# app.include_router(matches.router, prefix="/matches", tags=["Matches"])   - Response : `schemas.MatchResponse`

# app.include_router(projects.router, prefix="/projects", tags=["Projects"])

# app.include_router(teams.router, prefix="/teams", tags=["Teams"])6. **POST /matches/{match_id}/fix** :

# app.include_router(venues.router, prefix="/venues", tags=["Venues"])   - Mettre `est_fixe=True`, `statut="fixe"`

```   - Commit, refresh

   - Response : `{"message": "Match fix√©", "match": MatchResponse}`

**Points cl√©s** :

- **CORS** : Essentiel pour appels depuis frontend React (localhost:5173)7. **POST /matches/{match_id}/unfix** :

- **Production** : Restreindre `allow_origins` au domaine production   - Mettre `est_fixe=False`

- **Routers comment√©s** : D√©commenter apr√®s cr√©ation des routes   - Restaurer statut : "planifie" si cr√©neau existe (semaine non null), sinon "a_planifier"

   - Commit, refresh

---   - Response : `{"message": "Match d√©verrouill√©", "match": MatchResponse}`



### Sous-t√¢che 1.5.2 : Routes Matches8. **DELETE /matches/{match_id}** :

   - Supprimer de DB

**üìÅ Fichier √† cr√©er** : `backend/api/routes/matches.py`   - Commit

   - Status code 204 (no content)

**Imports requis** :

```python### Sous-t√¢che 3 : Routes Projects

from fastapi import APIRouter, Depends, HTTPException, status, Query**Fichier √† cr√©er** : `backend/api/routes/projects.py`

from sqlalchemy.orm import Session

from typing import List, Optional**Endpoints CRUD standard** :

- GET /projects/ ‚Üí liste

from backend.database.engine import get_db- GET /projects/{id} ‚Üí d√©tail

from backend.database import models- POST /projects/ ‚Üí cr√©ation

from backend.schemas import match as schemas- PUT /projects/{id} ‚Üí update

```- DELETE /projects/{id} ‚Üí suppression



**Router** :**Endpoint sp√©cifique** :

```python- **GET /projects/{id}/stats** ‚Üí retourner :

router = APIRouter()  - nb_matchs_total, nb_matchs_planifies, nb_matchs_fixes, nb_matchs_a_planifier

```  - Utiliser `.filter()` et `.count()` sur session



**Endpoints requis** :### Sous-t√¢che 4 : Routes Teams et Venues

**Fichiers √† cr√©er** : `backend/api/routes/teams.py`, `backend/api/routes/venues.py`

**1. GET /matches/ - Lister les matchs** :

```python**Endpoints CRUD standard** : GET list, GET detail, POST create, PUT update, DELETE

@router.get("/", response_model=List[schemas.MatchResponse])

def list_matches(### Consignes d'organisation

    project_id: Optional[int] = Query(None, description="Filtrer par projet"),- Toujours v√©rifier existence (404) avant op√©rations

    db: Session = Depends(get_db)- V√©rifier `est_modifiable` pour modifications de matchs

):- Dependency `Depends(get_db)` pour injection session

    """Lister tous les matchs, optionnellement filtr√©s par projet"""- Utiliser status codes HTTP appropri√©s (200, 201, 204, 400, 404)

    query = db.query(models.Match)- CORS essentiel pour dev local, restreindre en production

    

    if project_id is not None:### Impact et liens

        query = query.filter(models.Match.project_id == project_id)- Le frontend (`frontend/src/api/`) appellera ces endpoints.

    - Les sch√©mas Pydantic (`backend/schemas/`) valident les donn√©es.

    matches = query.all()- Les mod√®les SQLAlchemy (`backend/database/models.py`) sont manipul√©s.

    return matches

```## √Ä faire/v√©rifier

- Cr√©er l'application FastAPI avec CORS configur√©

**2. GET /matches/{match_id} - R√©cup√©rer un match** :- Impl√©menter toutes les routes avec gestion d'erreurs

```python- V√©rifier la logique m√©tier (est_modifiable, changements de statut)

@router.get("/{match_id}", response_model=schemas.MatchResponse)- Tester avec curl ou Swagger UI (/docs) :

def get_match(match_id: int, db: Session = Depends(get_db)):  - Cr√©er projet, √©quipes, matchs

    """R√©cup√©rer un match par son ID"""  - D√©placer match (move), fixer (fix), d√©fixer (unfix)

    match = db.query(models.Match).filter(models.Match.id == match_id).first()  - V√©rifier que match fix√© ne peut pas √™tre d√©plac√© (400)

    

    if not match:## Questions

        raise HTTPException(Poser des questions si des points sur la logique m√©tier, la s√©curit√©, les status codes ou l'int√©gration ne sont pas clairs.

            status_code=status.HTTP_404_NOT_FOUND,

            detail=f"Match {match_id} non trouv√©"## Documentation

        )Rester concis, ne pas ajouter de documentation excessive. Commenter bri√®vement les endpoints critiques si besoin.

    
    return match
```

**3. POST /matches/ - Cr√©er un match** :
```python
@router.post("/", response_model=schemas.MatchResponse, status_code=status.HTTP_201_CREATED)
def create_match(match: schemas.MatchCreate, db: Session = Depends(get_db)):
    """Cr√©er un nouveau match"""
    # V√©rifier que le projet existe
    project = db.query(models.Project).filter(models.Project.id == match.project_id).first()
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Projet {match.project_id} non trouv√©"
        )
    
    # Cr√©er le match
    db_match = models.Match(**match.model_dump())
    db.add(db_match)
    db.commit()
    db.refresh(db_match)
    
    return db_match
```

**4. PUT /matches/{match_id} - Mettre √† jour un match** :
```python
@router.put("/{match_id}", response_model=schemas.MatchResponse)
def update_match(
    match_id: int,
    match_update: schemas.MatchUpdate,
    db: Session = Depends(get_db)
):
    """Mettre √† jour un match (PATCH partiel)"""
    db_match = db.query(models.Match).filter(models.Match.id == match_id).first()
    
    if not db_match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match {match_id} non trouv√©"
        )
    
    # Update partiel (seulement champs fournis)
    update_data = match_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_match, key, value)
    
    db.commit()
    db.refresh(db_match)
    
    return db_match
```

**5. POST /matches/{match_id}/move - D√©placer un match (drag & drop)** :
```python
@router.post("/{match_id}/move", response_model=schemas.MatchResponse)
def move_match(
    match_id: int,
    move_data: schemas.MatchMove,
    db: Session = Depends(get_db)
):
    """D√©placer un match vers un nouveau cr√©neau (drag & drop)"""
    db_match = db.query(models.Match).filter(models.Match.id == match_id).first()
    
    if not db_match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match {match_id} non trouv√©"
        )
    
    # V√©rifier que le match est modifiable (logique m√©tier - T√¢che 1.1)
    if not db_match.est_modifiable:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ce match est fix√© et ne peut pas √™tre d√©plac√©"
        )
    
    # Mettre √† jour le cr√©neau
    db_match.semaine = move_data.semaine
    db_match.horaire = move_data.horaire
    db_match.gymnase = move_data.gymnase
    db_match.statut = "planifie"  # Changer statut apr√®s d√©placement
    
    db.commit()
    db.refresh(db_match)
    
    return db_match
```

**6. POST /matches/{match_id}/fix - Fixer un match** :
```python
@router.post("/{match_id}/fix")
def fix_match(match_id: int, db: Session = Depends(get_db)):
    """Fixer un match (le verrouiller pour emp√™cher replanification)"""
    db_match = db.query(models.Match).filter(models.Match.id == match_id).first()
    
    if not db_match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match {match_id} non trouv√©"
        )
    
    # Fixer le match
    db_match.est_fixe = True
    db_match.statut = "fixe"
    
    db.commit()
    db.refresh(db_match)
    
    return {
        "message": "Match fix√© avec succ√®s",
        "match": schemas.MatchResponse.model_validate(db_match)
    }
```

**7. POST /matches/{match_id}/unfix - D√©fixer un match** :
```python
@router.post("/{match_id}/unfix")
def unfix_match(match_id: int, db: Session = Depends(get_db)):
    """D√©fixer un match (le d√©verrouiller)"""
    db_match = db.query(models.Match).filter(models.Match.id == match_id).first()
    
    if not db_match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match {match_id} non trouv√©"
        )
    
    # D√©fixer le match
    db_match.est_fixe = False
    
    # Restaurer statut appropri√©
    if db_match.semaine is not None:
        db_match.statut = "planifie"  # Match d√©j√† planifi√©
    else:
        db_match.statut = "a_planifier"  # Match non planifi√©
    
    db.commit()
    db.refresh(db_match)
    
    return {
        "message": "Match d√©verrouill√© avec succ√®s",
        "match": schemas.MatchResponse.model_validate(db_match)
    }
```

**8. DELETE /matches/{match_id} - Supprimer un match** :
```python
@router.delete("/{match_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_match(match_id: int, db: Session = Depends(get_db)):
    """Supprimer un match"""
    db_match = db.query(models.Match).filter(models.Match.id == match_id).first()
    
    if not db_match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Match {match_id} non trouv√©"
        )
    
    db.delete(db_match)
    db.commit()
    
    return None  # 204 No Content
```

**Points cl√©s** :
- **Validation automatique** : Pydantic valide les sch√©mas (MatchCreate, MatchUpdate, MatchMove)
- **Logique m√©tier** : V√©rifier `est_modifiable` avant d√©placement (property du mod√®le)
- **Gestion d'erreurs** : HTTPException 404 (not found), 400 (bad request)
- **Conversion ORM** : `from_attributes=True` permet retour direct des mod√®les SQLAlchemy

---

### Sous-t√¢che 1.5.3 : Routes Projects

**üìÅ Fichier √† cr√©er** : `backend/api/routes/projects.py`

**Pattern CRUD standard** avec endpoint stats suppl√©mentaire :

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from backend.database.engine import get_db
from backend.database import models
from backend.schemas import project as schemas

router = APIRouter()

@router.get("/", response_model=List[schemas.ProjectResponse])
def list_projects(db: Session = Depends(get_db)):
    """Lister tous les projets"""
    return db.query(models.Project).all()

@router.get("/{project_id}", response_model=schemas.ProjectResponse)
def get_project(project_id: int, db: Session = Depends(get_db)):
    """R√©cup√©rer un projet par ID"""
    project = db.query(models.Project).filter(models.Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail=f"Projet {project_id} non trouv√©")
    return project

@router.post("/", response_model=schemas.ProjectResponse, status_code=201)
def create_project(project: schemas.ProjectCreate, db: Session = Depends(get_db)):
    """Cr√©er un nouveau projet"""
    db_project = models.Project(**project.model_dump())
    db.add(db_project)
    db.commit()
    db.refresh(db_project)
    return db_project

@router.put("/{project_id}", response_model=schemas.ProjectResponse)
def update_project(
    project_id: int,
    project_update: schemas.ProjectUpdate,
    db: Session = Depends(get_db)
):
    """Mettre √† jour un projet"""
    db_project = db.query(models.Project).filter(models.Project.id == project_id).first()
    if not db_project:
        raise HTTPException(status_code=404, detail=f"Projet {project_id} non trouv√©")
    
    update_data = project_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_project, key, value)
    
    db.commit()
    db.refresh(db_project)
    return db_project

@router.delete("/{project_id}", status_code=204)
def delete_project(project_id: int, db: Session = Depends(get_db)):
    """Supprimer un projet (et tous ses matchs/√©quipes/gymnases - cascade)"""
    db_project = db.query(models.Project).filter(models.Project.id == project_id).first()
    if not db_project:
        raise HTTPException(status_code=404, detail=f"Projet {project_id} non trouv√©")
    
    db.delete(db_project)
    db.commit()
    return None

@router.get("/{project_id}/stats", response_model=schemas.ProjectStats)
def get_project_stats(project_id: int, db: Session = Depends(get_db)):
    """R√©cup√©rer les statistiques d'un projet"""
    project = db.query(models.Project).filter(models.Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail=f"Projet {project_id} non trouv√©")
    
    # Calculer statistiques
    nb_matchs_total = db.query(models.Match).filter(models.Match.project_id == project_id).count()
    nb_matchs_planifies = db.query(models.Match).filter(
        models.Match.project_id == project_id,
        models.Match.semaine.isnot(None)
    ).count()
    nb_matchs_fixes = db.query(models.Match).filter(
        models.Match.project_id == project_id,
        models.Match.est_fixe == True
    ).count()
    nb_matchs_a_planifier = nb_matchs_total - nb_matchs_planifies
    
    nb_equipes = db.query(models.Team).filter(models.Team.project_id == project_id).count()
    nb_gymnases = db.query(models.Venue).filter(models.Venue.project_id == project_id).count()
    
    return schemas.ProjectStats(
        nb_matchs_total=nb_matchs_total,
        nb_matchs_planifies=nb_matchs_planifies,
        nb_matchs_fixes=nb_matchs_fixes,
        nb_matchs_a_planifier=nb_matchs_a_planifier,
        nb_equipes=nb_equipes,
        nb_gymnases=nb_gymnases
    )
```

---

### Sous-t√¢che 1.5.4 : Routes Teams et Venues

**üìÅ Fichiers √† cr√©er** : `backend/api/routes/teams.py`, `backend/api/routes/venues.py`

**Pattern CRUD identique** pour chaque :

```python
# teams.py ou venues.py
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from backend.database.engine import get_db
from backend.database import models
from backend.schemas import team as schemas  # ou venue as schemas

router = APIRouter()

@router.get("/", response_model=List[schemas.TeamResponse])  # ou VenueResponse
def list_items(
    project_id: Optional[int] = Query(None, description="Filtrer par projet"),
    db: Session = Depends(get_db)
):
    query = db.query(models.Team)  # ou models.Venue
    if project_id is not None:
        query = query.filter(models.Team.project_id == project_id)
    return query.all()

# GET /{id}, POST /, PUT /{id}, DELETE /{id} ‚Üí Pattern identique √† projects
```

---

### Impact et liens avec autres modules

**Utilisation par le frontend** (Phase 2) :
```typescript
// frontend/src/api/endpoints/matches.ts
export const matchesApi = {
  list: (projectId?: number) => axios.get(`/matches/`, { params: { project_id: projectId } }),
  move: (matchId: number, data: MatchMove) => axios.post(`/matches/${matchId}/move`, data),
  fix: (matchId: number) => axios.post(`/matches/${matchId}/fix`),
  unfix: (matchId: number) => axios.post(`/matches/${matchId}/unfix`),
}
```

**Service de synchronisation** (T√¢che 1.6) :
- Utilise les routes POST pour cr√©er projects/teams/venues/matches apr√®s import Excel
- Ou cr√©e directement les mod√®les ORM (pas besoin de passer par l'API)

---

## √Ä faire/v√©rifier

**Checklist de d√©veloppement** :

1. ‚úÖ Cr√©er `backend/api/main.py` avec FastAPI app, CORS, routes de base
2. ‚úÖ Cr√©er `backend/api/routes/matches.py` avec 8 endpoints (list, get, create, update, move, fix, unfix, delete)
3. ‚úÖ Cr√©er `backend/api/routes/projects.py` avec CRUD + stats
4. ‚úÖ Cr√©er `backend/api/routes/teams.py` avec CRUD + filtre project_id
5. ‚úÖ Cr√©er `backend/api/routes/venues.py` avec CRUD + filtre project_id
6. ‚úÖ D√©commenter les imports de routers dans `main.py`

**Checklist de validation** :

1. ‚úÖ D√©marrer le serveur API :
   ```bash
   cd backend
   uvicorn api.main:app --reload --port 8000
   ```
   ‚Üí Doit d√©marrer sans erreur

2. ‚úÖ Acc√©der √† la documentation Swagger :
   ```bash
   # Ouvrir http://localhost:8000/docs
   ```
   ‚Üí Doit afficher tous les endpoints (Matches, Projects, Teams, Venues)

3. ‚úÖ Tester un endpoint avec curl :
   ```bash
   # Health check
   curl http://localhost:8000/health
   # {"status":"ok"}
   
   # Lister matchs (vide si DB vide)
   curl http://localhost:8000/matches/
   # []
   ```

4. ‚úÖ Tester CORS (depuis frontend) :
   ```bash
   # Depuis localhost:5173, faire un fetch vers localhost:8000
   # Doit fonctionner gr√¢ce au CORS configur√©
   ```

5. ‚úÖ Tester la logique m√©tier (fix/unfix) :
   ```python
   # Via Swagger UI ou curl
   # 1. Cr√©er un match
   # 2. Le fixer : POST /matches/{id}/fix
   # 3. Essayer de le d√©placer : POST /matches/{id}/move ‚Üí Doit √©chouer (400)
   # 4. Le d√©fixer : POST /matches/{id}/unfix
   # 5. Le d√©placer : POST /matches/{id}/move ‚Üí Doit r√©ussir
   ```

**Commandes de test** :
```bash
# D√©marrer API
uvicorn backend.api.main:app --reload --port 8000

# Test health check
curl http://localhost:8000/health

# Test Swagger
xdg-open http://localhost:8000/docs  # Linux
open http://localhost:8000/docs      # Mac

# Tester cr√©ation projet
curl -X POST http://localhost:8000/projects/ \
  -H "Content-Type: application/json" \
  -d '{"nom":"Test","sport":"Volley","nb_semaines":26,"semaine_min":1}'
```

---

## Questions

**Questions critiques √† poser si quelque chose n'est pas clair** :

1. **Authentification** :
   - Faut-il ajouter une authentification (JWT, OAuth) ou rester en API ouverte ?
   - Faut-il limiter certaines routes (ex: DELETE) aux utilisateurs authentifi√©s ?

2. **Validation suppl√©mentaire** :
   - Faut-il v√©rifier que `semaine` est dans [1, nb_semaines] du projet ?
   - Faut-il v√©rifier que le gymnase existe avant de d√©placer un match ?
   - Faut-il v√©rifier la capacit√© du gymnase (nombre de matchs simultan√©s) ?

3. **Endpoints suppl√©mentaires** :
   - Faut-il un endpoint bulk pour fixer/d√©fixer plusieurs matchs ?
   - Faut-il un endpoint pour r√©initialiser tous les matchs d'un projet ?
   - Faut-il un endpoint pour exporter le calendrier en Excel/PDF ?

4. **Gestion d'erreurs** :
   - Faut-il un handler global d'exceptions (ex: ValidationError ‚Üí 422) ?
   - Faut-il logger les erreurs dans un fichier ?

5. **Performance** :
   - Faut-il paginer les r√©sultats (ex: GET /matches/?page=1&limit=50) ?
   - Faut-il ajouter un cache (ex: Redis pour /projects/{id}/stats) ?

---

## Documentation

Rester concis : documenter uniquement les choix non √©vidents :
- **CORS** : Expliquer pourquoi n√©cessaire pour React (diff√©rent domaine/port)
- **Logique m√©tier** : Documenter v√©rification `est_modifiable` avant d√©placement
- **Cascade delete** : Expliquer que DELETE project supprime aussi matchs/√©quipes/gymnases
- **Stats endpoint** : Documenter calculs (matchs planifi√©s, fixes, etc.)
- **Pattern CRUD** : Documenter une fois le pattern commun (GET list, GET detail, POST, PUT, DELETE)

√âviter la sur-documentation des concepts FastAPI standards.
