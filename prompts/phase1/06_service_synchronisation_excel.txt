# Prompt 1.6 : Service de synchronisation Excel ‚Üí Base# Prompt 1.6 : Service de synchronisation Excel ‚Üí Base



## Contexte global## Contexte global

PyCalendar V2 doit permettre d'importer des donn√©es depuis les fichiers de configuration (YAML + Excel) pour initialiser la base de donn√©es web. La synchronisation utilise les syst√®mes existants et doit √™tre fiable, robuste et facilement extensible.PyCalendar V2 doit permettre d'importer des donn√©es depuis des fichiers Excel/YAML pour initialiser ou mettre √† jour la base de donn√©es. La synchronisation doit √™tre fiable, robuste et facilement extensible pour supporter diff√©rents formats ou r√®gles m√©tier.



**CRUCIAL - Double configuration et validation** :## Contexte technique

1. **Fichier YAML** (ex: `configs/config_volley.yaml`) :Cette t√¢che concerne la cr√©ation d'un service de synchronisation capable de lire les fichiers Excel/YAML existants et d'alimenter la base de donn√©es avec les entit√©s du projet (Project, Team, Venue, Match).

   - Hyperparam√®tres : poids contraintes, strat√©gie, nb_semaines, semaine_minimum

   - R√©f√©rence le fichier Excel via `fichiers.donnees`## R√©sum√© du travail pr√©c√©dent

   - Charg√© par `core/config.py` ‚Üí classe `Config`- Les mod√®les SQLAlchemy sont en place (`backend/database/models.py`) avec toutes les relations.

- Les sch√©mas Pydantic sont d√©finis (`backend/schemas/`).

2. **Fichier Excel** (ex: `donnees/config_volley.xlsx`) :- Les routes API sont op√©rationnelles (`backend/api/routes/`).

   - **7+ feuilles** : Equipes, Gymnases, Indispos_Gymnases, Indispos_Equipes, Indispos_Institutions, Preferences_Gymnases, Obligation_Presence- Les besoins d'import de donn√©es depuis Excel/YAML sont identifi√©s.

   - Charg√© par `core/config_manager.py` ‚Üí classe `ConfigManager`

   - **Validation OBLIGATOIRE** : `actualiser_config.py` doit √™tre ex√©cut√© AVANT import pour valider/corriger structure## Objectifs

- D√©finir un service de synchronisation modulaire et testable.

3. **G√©n√©rateurs existants** :- S'assurer de la robustesse, de la gestion des erreurs et de la clart√© du code.

   - `generators/data_sources.py` : Classe `DataSource` charge √©quipes/gymnases depuis Excel- Pr√©voir l'extensibilit√© pour d'autres formats ou r√®gles m√©tier.

   - `generators/multi_pool_generator.py` : G√©n√®re les matchs (round-robin)

   - **Pr√©servation totale** : Code existant ne doit PAS √™tre modifi√©## D√©tails techniques



## Contexte technique### Fichier √† cr√©er

Cette t√¢che cr√©e un service de synchronisation qui charge YAML + Excel (valid√©) ‚Üí cr√©e Project, Teams, Venues, Matches dans la DB. Le service r√©utilise les classes existantes (`Config`, `ConfigManager`, `DataSource`, g√©n√©rateurs) sans les modifier.`backend/services/sync_service.py`



## R√©sum√© du travail pr√©c√©dent### Classe principale

- Les mod√®les SQLAlchemy stockent config YAML+Excel (`backend/database/models.py`) - T√¢che 1.3**SyncService**

- Les sch√©mas Pydantic sont d√©finis (`backend/schemas/`) - T√¢che 1.4

- Les routes API sont op√©rationnelles (`backend/api/routes/`) - T√¢che 1.5**Constructeur** : 

- `actualiser_config.py` valide la structure Excel- Accepter `db: Session`

- `ConfigManager` et `DataSource` chargent les donn√©es Excel- Stocker la session pour op√©rations DB

- G√©n√©rateurs produisent les matchs

### M√©thode principale

## Objectifs**`import_from_excel(config_path: str, project_name: str) -> models.Project`**

1. Cr√©er un service `SyncService` qui importe YAML + Excel ‚Üí DB

2. **Int√©grer la validation Excel** via `actualiser_config.py` (optionnel ou obligatoire)**Algorithme d√©taill√©** :

3. R√©utiliser `Config`, `ConfigManager`, `DataSource`, g√©n√©rateurs existants

4. Pr√©server totalement le code existant (aucune modification de generators/, core/)1. **Charger config** :

5. G√©rer erreurs et afficher statistiques d'import   - Utiliser `Config.from_yaml(config_path)` de `core/config.py`

   - R√©cup√©rer nb_semaines, semaine_min (via getattr pour compatibilit√©)

## D√©tails techniques

2. **Charger donn√©es Excel** :

### Fichier √† cr√©er   - Utiliser `DataSource(config.fichier_donnees)` de `generators/data_sources.py`

**üìÅ** `backend/services/sync_service.py`   - `equipes = source.charger_equipes()`

   - `gymnases = source.charger_gymnases()`

**Imports requis** :

```python3. **Cr√©er Project en DB** :

import json   - `project = models.Project(`

from pathlib import Path   - `nom=project_name,`

from sqlalchemy.orm import Session   - `sport=self._detect_sport(config),`

from typing import Optional, Dict, Any   - `config_yaml_path=config_path,`

   - `nb_semaines=config.nb_semaines,`

from core.config import Config   - `semaine_min=getattr(config, 'semaine_min', 1),`

from core.config_manager import ConfigManager   - `config_data=None  # optionnel: s√©rialiser config compl√®te en JSON`

from generators.data_sources import DataSource   - `)`

from generators.multi_pool_generator import MultiPoolGenerator   - `db.add(project)`

from backend.database import models   - `db.flush()` ‚Üí obtenir project.id pour FK

```

4. **Importer Teams** :

---   - It√©rer sur `equipes` (liste d'objets Equipe)

   - Pour chaque √©quipe :

### Classe SyncService     - `team = models.Team(`

     - `project_id=project.id,`

**Structure de la classe** :     - `nom=equipe.nom,`

```python     - `institution=equipe.institution,`

class SyncService:     - `numero_equipe=getattr(equipe, 'numero_equipe', None),`

    """Service de synchronisation YAML + Excel ‚Üí Base de donn√©es"""     - `genre=equipe.genre,`

         - `poule=equipe.poule,`

    def __init__(self, db: Session):     - `horaires_preferes=json.dumps(equipe.horaires_preferes),`

        self.db = db     - `lieux_preferes=json.dumps(equipe.lieux_preferes)`

         - `)`

    def import_from_excel(     - `db.add(team)`

        self, 

        yaml_path: str, 5. **Importer Venues** :

        project_name: Optional[str] = None,   - It√©rer sur `gymnases` (liste d'objets Gymnase)

        validate_excel: bool = True   - Pour chaque gymnase :

    ) -> models.Project:     - `venue = models.Venue(`

        """     - `project_id=project.id,`

        Importe un projet depuis config YAML + Excel.     - `nom=gymnase.nom,`

             - `capacite=getattr(gymnase, 'capacite', 1),`

        Args:     - `horaires_disponibles=json.dumps(gymnase.horaires_disponibles)`

            yaml_path: Chemin du fichier YAML (ex: "configs/config_volley.yaml")     - `)`

            project_name: Nom du projet (optionnel, sinon d√©duit du sport/Excel)     - `db.add(venue)`

            validate_excel: Si True, valider Excel avec actualiser_config.py avant import

        6. **G√©n√©rer et importer Matches** :

        Returns:   - `poules = source.get_poules_dict(equipes)` ‚Üí dict {poule: [equipes]}

            Project cr√©√© en DB avec Teams, Venues, Matches   - Instancier `MultiPoolGenerator()` de `generators/multi_pool_generator.py`

           - `matchs = generator.generer_matchs(poules)` ‚Üí liste de core.Match

        Raises:   - It√©rer sur matchs :

            FileNotFoundError: Si YAML ou Excel introuvable     - `match_db = models.Match(`

            ValueError: Si Excel invalide (structure incorrecte)     - `project_id=project.id,`

        """     - `equipe1_nom=match.equipe1.nom,`

        # ... (voir algorithme ci-dessous)     - `equipe1_institution=match.equipe1.institution,`

         - `equipe1_genre=match.equipe1.genre,`

    def _detect_sport(self, config: Config) -> str:     - `equipe2_nom=match.equipe2.nom,`

        """D√©tecte le sport depuis le chemin Excel ou config"""     - `equipe2_institution=match.equipe2.institution,`

        # ... (voir algorithme ci-dessous)     - `equipe2_genre=match.equipe2.genre,`

         - `poule=match.poule,`

    def _validate_excel_structure(self, excel_path: str) -> bool:     - `semaine=None,  # non planifi√©s initialement`

        """Valide la structure Excel avec actualiser_config.py (optionnel)"""     - `horaire=None,`

        # ... (voir algorithme ci-dessous)     - `gymnase=None,`

```     - `est_fixe=getattr(match, 'est_fixe', False),`

     - `statut=getattr(match, 'statut', 'a_planifier'),`

---     - `priorite=match.priorite`

     - `)`

### M√©thode principale : import_from_excel()     - `db.add(match_db)`



**Algorithme d√©taill√©** :7. **Commit final** :

   - `db.commit()`

**√âtape 1 : Charger config YAML** :   - `db.refresh(project)` ‚Üí recharger avec relations

```python

# 1. Charger config YAML8. **Retourner** :

print(f"üìÑ Chargement config YAML : {yaml_path}")   - `return project`

config = Config.from_yaml(yaml_path)

excel_path = config.fichier_donnees### M√©thode auxiliaire

**`_detect_sport(config: Config) -> str`**

# V√©rifier que le fichier Excel existe

if not Path(excel_path).exists():**Algorithme** :

    raise FileNotFoundError(f"Fichier Excel introuvable : {excel_path}")- R√©cup√©rer chemin Excel : `config.fichier_donnees`

- Si "volley" dans chemin.lower() ‚Üí return "volleyball"

print(f"üìä Fichier Excel d√©tect√© : {excel_path}")- Si "hand" dans chemin.lower() ‚Üí return "handball"

```- Sinon ‚Üí return "autre"



**√âtape 2 : Validation Excel (optionnel mais recommand√©)** :### Consignes d'organisation

```python- Utiliser `db.flush()` apr√®s Project pour obtenir ID avant FK

# 2. Valider structure Excel avec actualiser_config.py- S√©rialiser listes Python en JSON via `json.dumps()` pour colonnes JSON

if validate_excel:- `getattr(obj, 'attr', default)` pour compatibilit√© avec anciens configs/mod√®les

    print(f"üîç Validation structure Excel...")- Ne pas oublier commit final

    is_valid = self._validate_excel_structure(excel_path)- G√©rer exceptions si Excel/YAML invalides (try/except avec messages clairs)

    if not is_valid:

        raise ValueError(### Impact et liens

            f"Structure Excel invalide : {excel_path}\n"- Les scripts CLI (`scripts/import_excel.py`) utiliseront ce service.

            f"Ex√©cutez 'python actualiser_config.py {excel_path}' pour corriger"- Les mod√®les SQLAlchemy (`backend/database/models.py`) sont cr√©√©s.

        )- Le mod√®le m√©tier (`core/models.py`) est utilis√© pour g√©n√©rer les matchs.

    print(f"‚úÖ Structure Excel valid√©e")- Les g√©n√©rateurs existants (`generators/`) sont r√©utilis√©s sans modification.

```

## √Ä faire/v√©rifier

**√âtape 3 : Charger donn√©es Excel via ConfigManager** :- Cr√©er la classe SyncService avec m√©thode import_from_excel

```python- Impl√©menter la m√©thode _detect_sport

# 3. Charger donn√©es Excel via ConfigManager- G√©rer les erreurs (fichier manquant, format invalide)

print(f"üìã Chargement donn√©es Excel via ConfigManager...")- Tester l'import :

config_manager = ConfigManager(excel_path)  - Cr√©er session DB

  - Appeler `SyncService(db).import_from_excel(config_path, "Test")`

# Charger √©quipes depuis feuille "Equipes"  - V√©rifier en DB : 1 project, N teams, M venues, X matches non planifi√©s

# ConfigManager retourne un DataFrame, besoin de convertir en objets Equipe  - V√©rifier que les JSON sont bien s√©rialis√©s

# OPTION A : Utiliser DataSource (existant, pr√©f√©r√©)

# OPTION B : Parser directement depuis ConfigManager## Questions

# ‚Üí Utiliser DataSource car d√©j√† test√© et fonctionnelPoser des questions si des points sur le format Excel/YAML, la logique d'import, la gestion des erreurs ou l'int√©gration ne sont pas clairs.

```

## Documentation

**√âtape 4 : Charger √©quipes/gymnases via DataSource** :Rester concis, ne pas ajouter de documentation excessive. Commenter bri√®vement les √©tapes critiques si besoin (flush, s√©rialisation JSON).

```python
# 4. Charger √©quipes et gymnases via DataSource (existant, test√©)
print(f"üèê Chargement √©quipes et gymnases...")
data_source = DataSource(excel_path)
equipes = data_source.charger_equipes()  # Liste[core.models.Equipe]
gymnases = data_source.charger_gymnases()  # Liste[core.models.Gymnase]

print(f"  ‚Üí {len(equipes)} √©quipes charg√©es")
print(f"  ‚Üí {len(gymnases)} gymnases charg√©s")
```

**√âtape 5 : Cr√©er Project en DB** :
```python
# 5. Cr√©er Project en DB
sport = self._detect_sport(config)
if not project_name:
    project_name = f"{sport.capitalize()} {config.nb_semaines} semaines"

print(f"üèóÔ∏è Cr√©ation projet : {project_name}")

# Charger config YAML compl√®te en JSON (optionnel)
with open(yaml_path, 'r') as f:
    yaml_content = f.read()

project = models.Project(
    nom=project_name,
    sport=sport,
    config_yaml_path=str(Path(yaml_path).resolve()),
    config_excel_path=str(Path(excel_path).resolve()),
    config_yaml_data=yaml_content,  # Stocker YAML brut (ou None)
    config_excel_data=None,  # Optionnel : m√©tadonn√©es Excel (nombre feuilles, etc.)
    nb_semaines=config.nb_semaines,
    semaine_min=getattr(config, 'semaine_minimum', 1)  # YAML utilise "semaine_minimum"
)
self.db.add(project)
self.db.flush()  # Obtenir project.id pour FK

print(f"  ‚Üí Project ID: {project.id}")
```

**√âtape 6 : Importer Teams** :
```python
# 6. Importer Teams
print(f"üë• Import des √©quipes...")
teams_created = 0

for equipe in equipes:
    # Convertir horaires_preferes (liste Python) en JSON
    horaires_json = json.dumps(equipe.horaires_preferes) if hasattr(equipe, 'horaires_preferes') else None
    lieux_json = json.dumps(equipe.lieux_preferes) if hasattr(equipe, 'lieux_preferes') else None
    
    team = models.Team(
        project_id=project.id,
        nom=equipe.nom,
        institution=getattr(equipe, 'institution', None),
        numero_equipe=getattr(equipe, 'numero_equipe', None),
        genre=getattr(equipe, 'genre', None),
        poule=equipe.poule,
        horaires_preferes=horaires_json,
        lieux_preferes=lieux_json
    )
    self.db.add(team)
    teams_created += 1

print(f"  ‚Üí {teams_created} √©quipes cr√©√©es")
```

**√âtape 7 : Importer Venues** :
```python
# 7. Importer Venues (gymnases)
print(f"üèüÔ∏è Import des gymnases...")
venues_created = 0

for gymnase in gymnases:
    # Convertir horaires_disponibles en JSON
    horaires_json = json.dumps(gymnase.horaires_disponibles) if hasattr(gymnase, 'horaires_disponibles') else None
    
    venue = models.Venue(
        project_id=project.id,
        nom=gymnase.nom,
        capacite=getattr(gymnase, 'capacite', 1),
        horaires_disponibles=horaires_json
    )
    self.db.add(venue)
    venues_created += 1

print(f"  ‚Üí {venues_created} gymnases cr√©√©s")
```

**√âtape 8 : G√©n√©rer et importer Matches** :
```python
# 8. G√©n√©rer matchs via g√©n√©rateur existant
print(f"‚öΩ G√©n√©ration des matchs...")

# Grouper √©quipes par poule
poules = data_source.get_poules_dict(equipes)  # Dict[str, List[Equipe]]

# G√©n√©rer matchs (round-robin)
generator = MultiPoolGenerator()
matchs_core = generator.generer_matchs(poules)  # Liste[core.models.Match]

print(f"  ‚Üí {len(matchs_core)} matchs g√©n√©r√©s")

# Importer matchs en DB
print(f"üíæ Import des matchs...")
matches_created = 0

for match in matchs_core:
    match_db = models.Match(
        project_id=project.id,
        equipe1_nom=match.equipe1.nom,
        equipe1_institution=getattr(match.equipe1, 'institution', None),
        equipe1_genre=getattr(match.equipe1, 'genre', None),
        equipe2_nom=match.equipe2.nom,
        equipe2_institution=getattr(match.equipe2, 'institution', None),
        equipe2_genre=getattr(match.equipe2, 'genre', None),
        poule=match.poule,
        semaine=None,  # Non planifi√©s initialement
        horaire=None,
        gymnase=None,
        est_fixe=getattr(match, 'est_fixe', False),  # T√¢che 1.1
        statut=getattr(match, 'statut', 'a_planifier'),  # T√¢che 1.1
        priorite=getattr(match, 'priorite', 0)
    )
    self.db.add(match_db)
    matches_created += 1

print(f"  ‚Üí {matches_created} matchs cr√©√©s")
```

**√âtape 9 : Commit et retour** :
```python
# 9. Commit final
self.db.commit()
self.db.refresh(project)  # Recharger avec relations

# Afficher r√©sum√©
print(f"\n‚úÖ Import termin√© avec succ√®s!")
print(f"   üìä Projet : {project.nom} (ID: {project.id})")
print(f"   üë• √âquipes : {teams_created}")
print(f"   üèüÔ∏è Gymnases : {venues_created}")
print(f"   ‚öΩ Matchs : {matches_created}")

return project
```

---

### M√©thode auxiliaire : _detect_sport()

```python
def _detect_sport(self, config: Config) -> str:
    """D√©tecte le sport depuis le chemin Excel ou config YAML"""
    excel_path = config.fichier_donnees.lower()
    
    if "volley" in excel_path or "volleyball" in excel_path:
        return "Volleyball"
    elif "hand" in excel_path or "handball" in excel_path:
        return "Handball"
    elif "basket" in excel_path:
        return "Basketball"
    elif "foot" in excel_path or "football" in excel_path:
        return "Football"
    else:
        return "Autre"
```

---

### M√©thode auxiliaire : _validate_excel_structure()

```python
def _validate_excel_structure(self, excel_path: str) -> bool:
    """
    Valide la structure Excel avec actualiser_config.py.
    
    OPTION 1 (Recommand√©) : Appeler le script via subprocess
    OPTION 2 : Importer directement les fonctions de validation
    
    Retourne True si valide, False sinon.
    """
    try:
        # OPTION 1 : Appel subprocess (isolation, s√©curit√©)
        import subprocess
        result = subprocess.run(
            ["python", "actualiser_config.py", excel_path, "--validate-only"],
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.returncode == 0
        
        # OPTION 2 : Import direct (plus rapide, moins isol√©)
        # from actualiser_config import valider_structure_excel
        # rapport = valider_structure_excel(excel_path)
        # return rapport.is_valid()
        
    except Exception as e:
        print(f"‚ö†Ô∏è Validation Excel √©chou√©e : {e}")
        return False  # En cas d'erreur, continuer (validation optionnelle)
```

**‚ö†Ô∏è IMPORTANT** : `actualiser_config.py` doit avoir un mode `--validate-only` qui retourne 0 si OK, 1 si erreurs. Si ce mode n'existe pas, il faut soit :
- L'ajouter au script
- Ou utiliser l'import direct (OPTION 2)
- Ou demander √† l'utilisateur d'ex√©cuter manuellement le script avant import

---

### Consignes d'organisation

**Ordre d'ex√©cution** :
1. Validation Excel (actualiser_config.py) ‚Üí AVANT tout
2. Chargement YAML (Config.from_yaml)
3. Chargement Excel (DataSource)
4. Cr√©ation Project (DB flush pour ID)
5. Cr√©ation Teams, Venues (utiliser project.id)
6. G√©n√©ration Matches (g√©n√©rateur existant)
7. Cr√©ation Matches (DB)
8. Commit final

**Gestion des donn√©es** :
- **JSON s√©rialisation** : `json.dumps()` pour listes Python ‚Üí colonnes JSON DB
- **getattr() pour compatibilit√©** : Anciens mod√®les n'ont pas tous les champs
- **Path.resolve()** : Chemins absolus pour config_yaml_path, config_excel_path

**Gestion d'erreurs** :
- FileNotFoundError si YAML ou Excel introuvable
- ValueError si Excel invalide (structure)
- Try/except autour de la validation Excel (optionnelle)

---

### Impact et liens avec autres modules

**Utilisation par les scripts CLI** (T√¢che 1.7) :
```python
# scripts/import_excel.py
from backend.database.engine import SessionLocal, init_db
from backend.services.sync_service import SyncService

init_db()
db = SessionLocal()
service = SyncService(db)

try:
    project = service.import_from_excel(
        yaml_path="configs/config_volley.yaml",
        project_name="Championnat Volley 2025",
        validate_excel=True  # Valider avant import
    )
    print(f"‚úÖ Projet {project.id} import√©!")
finally:
    db.close()
```

**R√©utilisation du code existant** :
- ‚úÖ `core/config.py` : Config.from_yaml() - PR√âSERV√â
- ‚úÖ `core/config_manager.py` : ConfigManager - PR√âSERV√â
- ‚úÖ `generators/data_sources.py` : DataSource - PR√âSERV√â
- ‚úÖ `generators/multi_pool_generator.py` : G√©n√©ration matchs - PR√âSERV√â
- ‚úÖ `actualiser_config.py` : Validation Excel - R√âUTILIS√â

**√âvolution future** :
- Ajouter m√©thode `update_from_excel()` pour re-synchroniser un projet existant
- Ajouter m√©thode `export_to_excel()` pour exporter DB ‚Üí Excel
- G√©rer les conflits (matchs modifi√©s dans DB vs Excel)

---

## √Ä faire/v√©rifier

**Checklist de d√©veloppement** :

1. ‚úÖ Cr√©er `backend/services/sync_service.py`
2. ‚úÖ Cr√©er classe `SyncService` avec constructeur `__init__(db: Session)`
3. ‚úÖ Impl√©menter `import_from_excel()` avec les 9 √©tapes de l'algorithme
4. ‚úÖ Impl√©menter `_detect_sport()` avec d√©tection depuis chemin Excel
5. ‚úÖ Impl√©menter `_validate_excel_structure()` (optionnel)
6. ‚úÖ Ajouter gestion d'erreurs (FileNotFoundError, ValueError)
7. ‚úÖ Ajouter logs/prints pour suivre progression

**Checklist de validation** :

1. ‚úÖ **Pr√©parer fichier Excel valide** :
   ```bash
   # Si actualiser_config.py a mode validation
   python actualiser_config.py donnees/config_volley.xlsx --validate-only
   # Doit retourner 0 (OK)
   ```

2. ‚úÖ **Tester import complet** :
   ```python
   from backend.database.engine import SessionLocal, init_db
   from backend.services.sync_service import SyncService
   
   # Initialiser DB
   init_db()
   
   # Import
   db = SessionLocal()
   service = SyncService(db)
   
   project = service.import_from_excel(
       yaml_path="configs/config_volley.yaml",
       project_name="Test Import",
       validate_excel=True
   )
   
   print(f"Project ID: {project.id}")
   print(f"Teams: {len(project.teams)}")
   print(f"Venues: {len(project.venues)}")
   print(f"Matches: {len(project.matches)}")
   
   db.close()
   ```

3. ‚úÖ **V√©rifier en DB** :
   ```bash
   sqlite3 database/pycalendar.db "SELECT * FROM projects;"
   sqlite3 database/pycalendar.db "SELECT COUNT(*) FROM teams;"
   sqlite3 database/pycalendar.db "SELECT COUNT(*) FROM venues;"
   sqlite3 database/pycalendar.db "SELECT COUNT(*) FROM matches WHERE semaine IS NULL;"
   # Tous les matchs doivent avoir semaine=NULL (non planifi√©s)
   ```

4. ‚úÖ **Tester JSON s√©rialisation** :
   ```python
   db = SessionLocal()
   team = db.query(models.Team).first()
   
   # V√©rifier JSON
   import json
   horaires = json.loads(team.horaires_preferes) if team.horaires_preferes else []
   print(f"Horaires pr√©f√©r√©s : {horaires}")
   
   db.close()
   ```

5. ‚úÖ **Tester gestion d'erreurs** :
   ```python
   # Fichier inexistant
   try:
       service.import_from_excel("configs/inexistant.yaml")
   except FileNotFoundError as e:
       print(f"‚úÖ Erreur captur√©e : {e}")
   
   # Excel invalide (si validation activ√©e)
   try:
       service.import_from_excel("configs/test_invalide.yaml", validate_excel=True)
   except ValueError as e:
       print(f"‚úÖ Erreur captur√©e : {e}")
   ```

**Commandes de test** :
```bash
# Cr√©er DB
python -c "from backend.database.engine import init_db; init_db()"

# Valider Excel
python actualiser_config.py donnees/config_volley.xlsx

# Import via Python
python -c "
from backend.database.engine import SessionLocal
from backend.services.sync_service import SyncService

db = SessionLocal()
service = SyncService(db)
project = service.import_from_excel('configs/config_volley.yaml', 'Test')
print(f'‚úÖ Import OK: {len(project.matches)} matchs')
db.close()
"
```

---

## Questions

**Questions critiques √† poser si quelque chose n'est pas clair** :

1. **Validation Excel** :
   - `actualiser_config.py` a-t-il un mode `--validate-only` retournant un code de sortie ?
   - Faut-il l'ajouter ou utiliser import direct des fonctions de validation ?
   - La validation doit-elle √™tre obligatoire ou optionnelle (param√®tre validate_excel) ?

2. **Structure Excel** :
   - Toutes les feuilles requises (Equipes, Gymnases, etc.) sont-elles bien pr√©sentes ?
   - Quelles colonnes exactes dans chaque feuille ? (pour parser avec ConfigManager)
   - Faut-il utiliser ConfigManager OU DataSource ? (DataSource semble plus simple)

3. **Stockage config** :
   - Faut-il stocker le contenu complet du YAML en JSON (config_yaml_data) ?
   - Faut-il stocker des m√©tadonn√©es Excel (nombre de feuilles, lignes, etc.) ?
   - Ou laisser ces champs NULL et stocker seulement les chemins ?

4. **Gestion des conflits** :
   - Que faire si le projet existe d√©j√† (m√™me nom) ? Erreur ? √âcrasement ? Versioning ?
   - Faut-il une m√©thode `update_from_excel()` pour re-synchroniser ?

5. **Performance** :
   - Faut-il utiliser `bulk_insert_mappings()` pour ins√©rer Teams/Venues/Matches plus rapidement ?
   - Ou garder la boucle simple avec `db.add()` pour chaque entit√© ?

6. **Pr√©f√©rences gymnases** :
   - Comment extraire `lieux_preferes` par √©quipe ? Depuis feuille "Preferences_Gymnases" ?
   - DataSource g√®re-t-il cela automatiquement ou faut-il parser manuellement ?

---

## Documentation

Rester concis : documenter uniquement les choix non √©vidents :
- **Validation Excel** : Expliquer pourquoi actualiser_config.py est appel√© (structure correcte)
- **R√©utilisation code** : Documenter que DataSource, g√©n√©rateurs sont pr√©serv√©s
- **JSON s√©rialisation** : Expliquer conversion listes Python ‚Üí JSON pour DB
- **Ordre flush/commit** : Expliquer pourquoi flush apr√®s Project (obtenir ID pour FK)
- **semaine_minimum vs semaine_min** : Documenter diff√©rence nom YAML/DB

√âviter la sur-documentation des concepts SQLAlchemy/Python standards.
