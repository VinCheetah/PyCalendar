# Prompt 1.8 : Tests Unitaires Backend# Prompt 1.8 : Tests unitaires ‚Äì Backend



## Contexte global## Contexte global

PyCalendar V2 utilise pytest pour les tests unitaires du backend. Les tests doivent valider les mod√®les, services, routes API et la logique m√©tier, en tenant compte de la double configuration (YAML + Excel).PyCalendar V2 doit garantir la fiabilit√© du backend par des tests unitaires couvrant les mod√®les de base de donn√©es, la logique m√©tier et les endpoints API. Les tests doivent √™tre clairs, organis√©s, facilement extensibles et maintenables.



**RAPPEL - Double configuration** :## Contexte technique

- **Fichier YAML** : Hyperparam√®tres + r√©f√©rence au fichier Excel (configs/default.yaml, configs/config_volley.yaml)Cette t√¢che concerne la d√©finition et l'organisation des tests unitaires pour le backend, en coh√©rence avec les √©volutions pr√©c√©dentes (mod√®les, API, service de synchronisation).

- **Fichier Excel** : Donn√©es d√©taill√©es (7+ feuilles : Equipes, Gymnases, Indispos, Preferences, etc.)

- **Validation** : `actualiser_config.py` valide la structure Excel AVANT import## R√©sum√© du travail pr√©c√©dent

- **Pas de d√©faut dans .py** : Tous les defaults dans configs/default.yaml- Les mod√®les SQLAlchemy sont en place (`backend/database/models.py`) avec propri√©t√©s calcul√©es.

- Les sch√©mas Pydantic sont d√©finis (`backend/schemas/`).

## Contexte technique- Les routes API sont op√©rationnelles (`backend/api/routes/`).

Cette t√¢che cr√©e une suite de tests unitaires compl√®te pour valider :- Les scripts CLI sont cr√©√©s (`scripts/`).

1. Mod√®les SQLAlchemy (Project, Team, Venue, Match)- Les besoins de validation et de robustesse sont identifi√©s.

2. Service de synchronisation (SyncService) avec double config

3. Routes API (projects, teams, venues, matches)## Objectifs

4. Logique m√©tier (matchs fixes, d√©placement, contraintes)- D√©finir des tests unitaires couvrant les cas principaux et les cas limites.

- S'assurer de la clart√©, de l'organisation et de l'extensibilit√© des tests.

## R√©sum√© du travail pr√©c√©dent- Pr√©voir la maintenance et l'√©volution des tests pour de nouvelles fonctionnalit√©s.

- Mod√®les DB cr√©√©s avec config_yaml_path, config_excel_path (T√¢che 1.3)

- Sch√©mas Pydantic cr√©√©s avec config_yaml_data, config_excel_data (T√¢che 1.4)## D√©tails techniques

- Routes API compl√®tes avec 8 endpoints matchs (T√¢che 1.5)

- SyncService avec validation Excel via actualiser_config.py (T√¢che 1.6)### Structure des tests

- Scripts CLI init_db.py et import_excel.py (T√¢che 1.7)**Dossiers √† cr√©er** : `tests/`, `tests/unit/`



## Objectifs### Fichier de configuration pytest

1. Cr√©er fixtures r√©utilisables (DB test, configs YAML/Excel)**Cr√©er** : `tests/conftest.py`

2. Tester mod√®les SQLAlchemy (relations, cascade delete)

3. Tester SyncService (import, validation Excel, g√©n√©ration matchs)**Fixtures requises** :

4. Tester routes API (CRUD, move, fix, unfix, stats)

5. Assurer couverture > 80% du code backend1. **db_engine** :

   - Cr√©er engine SQLite en m√©moire (`:memory:`)

## D√©tails techniques   - `Base.metadata.create_all(engine)`

   - Yield engine

### Configuration pytest   - Cleanup : `Base.metadata.drop_all(engine)`



**üìÅ Fichier √† cr√©er** : `backend/tests/conftest.py`2. **db_session** :

   - Utiliser fixture `db_engine`

**Contenu complet** :   - Cr√©er `SessionLocal()` li√©e √† l'engine

   - Yield session

```python   - Close session dans cleanup

"""

Configuration pytest pour PyCalendar backend.3. **sample_project** :

   - Utiliser fixture `db_session`

D√©finit les fixtures partag√©es entre tous les tests.   - Cr√©er et commit `models.Project` de test

"""   - Exemple : nom="Test", sport="volleyball", nb_semaines=20

   - Refresh et yield project

import pytest

from pathlib import Path**Consignes** :

from sqlalchemy import create_engine- SQLite in-memory pour rapidit√© des tests

from sqlalchemy.orm import sessionmaker- Cleanup syst√©matique via yield/teardown

from fastapi.testclient import TestClient- Scope par d√©faut (function) pour isolation entre tests

import tempfile

import shutil### Tests des mod√®les

**Fichier √† cr√©er** : `tests/unit/test_models.py`

from backend.database.base import Base

from backend.api.main import app**Tests requis** :

from backend.database.engine import get_db

1. **test_create_project** :

# Cr√©ation DB en m√©moire pour tests   - Cr√©er `models.Project` avec nom, sport

SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"   - `db.add()`, `db.commit()`

   - Assert `project.id is not None`

@pytest.fixture(scope="function")   - Assert `project.nom == "Test"`

def test_db():

    """2. **test_create_match** :

    Fixture pour cr√©er DB de test en m√©moire.   - Utiliser fixture `sample_project`

       - Cr√©er `models.Match` li√© au projet

    Yield:   - Champs : equipe1_nom, equipe2_nom, poule

        Session: Session SQLAlchemy de test   - Pas de cr√©neau (semaine=None)

    """   - `db.add()`, `db.commit()`

    # Cr√©er engine + tables   - Assert `match.id is not None`

    engine = create_engine(   - Assert `match.est_planifie == False`

        SQLALCHEMY_DATABASE_URL,    - Assert `match.est_modifiable == True`

        connect_args={"check_same_thread": False}

    )3. **test_fix_match** :

    Base.metadata.create_all(bind=engine)   - Cr√©er Match avec cr√©neau (semaine=1, horaire="09:00", gymnase="Gym A")

       - Fixer : `match.est_fixe = True`, `match.statut = "fixe"`

    # Cr√©er session   - Commit

    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)   - Assert `match.est_modifiable == False`

    db = TestingSessionLocal()

    4. **test_match_properties** :

    yield db   - Match sans cr√©neau ‚Üí `est_planifie == False`

       - Ajouter cr√©neau ‚Üí `est_planifie == True`

    # Cleanup   - Match avec statut "termine" ‚Üí `est_modifiable == False`

    db.close()

    Base.metadata.drop_all(bind=engine)5. **test_cascade_delete** :

   - Cr√©er Project avec Teams, Venues, Matches

@pytest.fixture(scope="function")   - `db.delete(project)`, `db.commit()`

def client(test_db):   - V√©rifier que teams, venues, matches sont aussi supprim√©s

    """

    Fixture pour cr√©er client FastAPI de test.**Consignes** :

    - Tester les propri√©t√©s calcul√©es (est_planifie, est_modifiable)

    Override la d√©pendance get_db pour utiliser test_db.- V√©rifier la logique m√©tier (fixation, statut)

    - Tester les relations et cascade delete

    Yield:

        TestClient: Client FastAPI de test### Tests API (optionnel mais recommand√©)

    """**Fichier √† cr√©er** : `tests/unit/test_api_matches.py`

    def override_get_db():

        yield test_db**Setup** :

    - Utiliser `TestClient` de FastAPI

    app.dependency_overrides[get_db] = override_get_db- Fixture `client` qui retourne `TestClient(app)`

    - Override dependency `get_db` pour utiliser db_session de test

    with TestClient(app) as c:

        yield c**Tests basiques** :

    

    # Cleanup1. **test_health_endpoint** :

    app.dependency_overrides.clear()   - GET /health

   - Assert status 200

@pytest.fixture(scope="function")   - Assert `{"status": "ok"}`

def config_yaml_file():

    """2. **test_get_matches_empty** :

    Fixture pour cr√©er fichier YAML de test.   - GET /matches/

       - Assert status 200

    Yield:   - Assert `[]`

        Path: Chemin vers YAML temporaire

    """3. **test_create_match** :

    # Cr√©er r√©pertoire temporaire   - POST /matches/ avec MatchCreate

    temp_dir = Path(tempfile.mkdtemp())   - Assert status 201

    yaml_path = temp_dir / "config_test.yaml"   - Assert response contient id, champs corrects

    

    # Contenu YAML minimal (semaine_minimum DANS YAML, pas dans .py)4. **test_move_match** :

    yaml_content = """   - Cr√©er match non fix√©

sport: "Volleyball"   - POST /matches/{id}/move avec MatchMove

   - Assert status 200

semaines:   - Assert semaine/horaire/gymnase mis √† jour

  semaine_minimum: 2   - Assert statut == "planifie"

  nb_semaines: 10

5. **test_move_fixed_match_fails** :

contraintes:   - Cr√©er match fix√©

  poids:   - POST /matches/{id}/move

    respect_repos: 10.0   - Assert status 400

    equilibre_domicile_exterieur: 8.0   - Assert message d'erreur clair

    respect_indisponibilites: 20.0

    respect_preferences: 5.06. **test_fix_unfix_match** :

   - POST /matches/{id}/fix ‚Üí assert est_fixe=True

solver:   - POST /matches/{id}/unfix ‚Üí assert est_fixe=False

  strategie: "optimal"

  temps_max_secondes: 300**Consignes** :

- Override dependency get_db pour isolation

fichiers:- Tester les status codes HTTP

  donnees: "test_data.xlsx"- V√©rifier les r√©ponses JSON

"""- Tester les cas d'erreur (404, 400)

    

    yaml_path.write_text(yaml_content)### Configuration pytest

    **Cr√©er** : `pytest.ini` (optionnel)

    yield yaml_path

    ```ini

    # Cleanup[pytest]

    shutil.rmtree(temp_dir)testpaths = tests

python_files = test_*.py

@pytest.fixture(scope="function")python_classes = Test*

def config_excel_file():python_functions = test_*

    """```

    Fixture pour cr√©er fichier Excel de test.

    ### Consignes d'organisation

    Yield:- Isolation des tests (chaque test ind√©pendant)

        Path: Chemin vers Excel temporaire- Nommage clair et descriptif

    """- Utiliser fixtures pour setup/teardown

    import pandas as pd- Couvrir les cas principaux ET les cas limites

    - Documenter les tests complexes si besoin

    # Cr√©er r√©pertoire temporaire

    temp_dir = Path(tempfile.mkdtemp())### Impact et liens

    excel_path = temp_dir / "test_data.xlsx"- Les mod√®les SQLAlchemy (`backend/database/models.py`) sont test√©s.

    - Les routes API (`backend/api/routes/`) sont test√©es.

    # Feuille Equipes- Le service de synchronisation (`backend/services/sync_service.py`) peut √™tre test√© s√©par√©ment.

    df_equipes = pd.DataFrame({

        "Institution": ["Lyc√©e A", "Lyc√©e A", "Lyc√©e B"],## √Ä faire/v√©rifier

        "Num√©ro √©quipe": [1, 2, 1],- Cr√©er la structure tests/ avec conftest.py

        "Niveau": ["Minimes", "Minimes", "Minimes"],- Impl√©menter les fixtures (db_engine, db_session, sample_project)

        "Cat√©gorie": ["Gar√ßons", "Gar√ßons", "Filles"],- Cr√©er test_models.py avec tests des mod√®les

        "Poule": ["P1", "P1", "P1"],- (Optionnel) Cr√©er test_api_matches.py avec tests API

        "Gymnase pr√©f√©r√©": ["Gymnase 1", "Gymnase 1", "Gymnase 2"]- Ex√©cuter les tests : `pytest tests/ -v`

    })- V√©rifier la couverture : `pytest tests/ --cov=backend --cov-report=term-missing`

    - Objectif : couverture >80% sur les modules critiques

    # Feuille Gymnases

    df_gymnases = pd.DataFrame({## Questions

        "Nom": ["Gymnase 1", "Gymnase 2"],Poser des questions si des points sur la structure des tests, les fixtures, la couverture ou l'int√©gration ne sont pas clairs.

        "Capacit√©": [100, 80],

        "Adresse": ["Rue A", "Rue B"]## Documentation

    })Rester concis, ne pas ajouter de documentation excessive. Commenter bri√®vement les tests complexes ou les cas limites si besoin.

    
    # Feuille Indispos_Gymnases
    df_indispo_gym = pd.DataFrame({
        "Gymnase": ["Gymnase 1"],
        "Date d√©but": ["2025-01-15"],
        "Date fin": ["2025-01-20"],
        "Raison": ["Travaux"]
    })
    
    # Feuille Indispos_Equipes
    df_indispo_equipes = pd.DataFrame({
        "Institution": ["Lyc√©e A"],
        "Num√©ro √©quipe": [1],
        "Niveau": ["Minimes"],
        "Cat√©gorie": ["Gar√ßons"],
        "Date d√©but": ["2025-02-10"],
        "Date fin": ["2025-02-15"],
        "Raison": ["Stage"]
    })
    
    # Feuille Indispos_Institutions
    df_indispo_inst = pd.DataFrame({
        "Institution": ["Lyc√©e B"],
        "Date d√©but": ["2025-03-01"],
        "Date fin": ["2025-03-05"],
        "Raison": ["Vacances"]
    })
    
    # Feuille Preferences_Gymnases
    df_prefs = pd.DataFrame({
        "Institution": ["Lyc√©e A"],
        "Gymnase pr√©f√©r√©": ["Gymnase 1"],
        "Priorit√©": [1]
    })
    
    # Feuille Obligation_Presence
    df_oblig = pd.DataFrame({
        "Institution": ["Lyc√©e A"],
        "Semaine": [3],
        "Raison": ["√âv√©nement local"]
    })
    
    # √âcrire Excel
    with pd.ExcelWriter(excel_path, engine='openpyxl') as writer:
        df_equipes.to_excel(writer, sheet_name='Equipes', index=False)
        df_gymnases.to_excel(writer, sheet_name='Gymnases', index=False)
        df_indispo_gym.to_excel(writer, sheet_name='Indispos_Gymnases', index=False)
        df_indispo_equipes.to_excel(writer, sheet_name='Indispos_Equipes', index=False)
        df_indispo_inst.to_excel(writer, sheet_name='Indispos_Institutions', index=False)
        df_prefs.to_excel(writer, sheet_name='Preferences_Gymnases', index=False)
        df_oblig.to_excel(writer, sheet_name='Obligation_Presence', index=False)
    
    yield excel_path
    
    # Cleanup
    shutil.rmtree(temp_dir)
```

**Points cl√©s** :
- **DB en m√©moire** : sqlite:///:memory: pour rapidit√©
- **Scope function** : Nouvelle DB/session pour chaque test (isolation)
- **Override get_db** : FastAPI utilise test_db au lieu de DB r√©elle
- **Fixtures YAML/Excel** : Fichiers temporaires avec structure compl√®te (7 feuilles)
- **Cleanup automatique** : tempfile + shutil.rmtree

---

### Tests des mod√®les

**üìÅ Fichier √† cr√©er** : `backend/tests/test_models.py`

**Contenu complet** :

```python
"""
Tests des mod√®les SQLAlchemy.
"""

import pytest
from backend.database.models import Project, Team, Venue, Match

def test_create_project(test_db):
    """Test cr√©ation Project avec configs YAML+Excel."""
    project = Project(
        nom="Test Project",
        sport="Volleyball",
        nb_semaines=10,
        semaine_min=2,
        config_yaml_path="/path/to/config.yaml",
        config_excel_path="/path/to/data.xlsx",
        config_yaml_data={"sport": "Volleyball", "nb_semaines": 10},
        config_excel_data={"equipes": 3, "gymnases": 2}
    )
    test_db.add(project)
    test_db.commit()
    
    assert project.id is not None
    assert project.nom == "Test Project"
    assert project.config_yaml_path == "/path/to/config.yaml"
    assert project.config_excel_path == "/path/to/data.xlsx"
    assert project.config_yaml_data["sport"] == "Volleyball"
    assert project.config_excel_data["gymnases"] == 2

def test_create_team(test_db):
    """Test cr√©ation Team avec source Excel."""
    project = Project(nom="Test", sport="Volley", nb_semaines=5, semaine_min=1)
    test_db.add(project)
    test_db.commit()
    
    team = Team(
        project_id=project.id,
        nom="Lyc√©e A - 1",
        institution="Lyc√©e A",
        numero=1,
        niveau="Minimes",
        categorie="Gar√ßons",
        poule="P1"
    )
    test_db.add(team)
    test_db.commit()
    
    assert team.id is not None
    assert team.project_id == project.id
    assert team.nom == "Lyc√©e A - 1"

def test_cascade_delete_project(test_db):
    """Test cascade delete : supprimer project supprime teams/venues/matches."""
    # Cr√©er project
    project = Project(nom="Test", sport="Volley", nb_semaines=5, semaine_min=1)
    test_db.add(project)
    test_db.commit()
    project_id = project.id
    
    # Cr√©er √©quipes
    team1 = Team(project_id=project_id, nom="Team 1", institution="A", numero=1, niveau="M", categorie="G", poule="P1")
    team2 = Team(project_id=project_id, nom="Team 2", institution="B", numero=1, niveau="M", categorie="G", poule="P1")
    test_db.add_all([team1, team2])
    test_db.commit()
    
    # Cr√©er gymnase
    venue = Venue(project_id=project_id, nom="Gym 1")
    test_db.add(venue)
    test_db.commit()
    
    # Cr√©er match
    match = Match(
        project_id=project_id,
        equipe_domicile_id=team1.id,
        equipe_exterieur_id=team2.id,
        gymnase_id=venue.id,
        semaine=3
    )
    test_db.add(match)
    test_db.commit()
    
    # V√©rifier existence
    assert test_db.query(Team).filter_by(project_id=project_id).count() == 2
    assert test_db.query(Venue).filter_by(project_id=project_id).count() == 1
    assert test_db.query(Match).filter_by(project_id=project_id).count() == 1
    
    # Supprimer project
    test_db.delete(project)
    test_db.commit()
    
    # V√©rifier cascade delete
    assert test_db.query(Team).filter_by(project_id=project_id).count() == 0
    assert test_db.query(Venue).filter_by(project_id=project_id).count() == 0
    assert test_db.query(Match).filter_by(project_id=project_id).count() == 0

def test_match_modifiable_logic(test_db):
    """Test logique est_modifiable (False si est_fixe ou avant semaine_min)."""
    project = Project(nom="Test", sport="Volley", nb_semaines=10, semaine_min=2)
    test_db.add(project)
    test_db.commit()
    
    team1 = Team(project_id=project.id, nom="T1", institution="A", numero=1, niveau="M", categorie="G", poule="P1")
    team2 = Team(project_id=project.id, nom="T2", institution="B", numero=1, niveau="M", categorie="G", poule="P1")
    venue = Venue(project_id=project.id, nom="Gym")
    test_db.add_all([team1, team2, venue])
    test_db.commit()
    
    # Match normal semaine 3 (>= semaine_min) : modifiable
    match1 = Match(
        project_id=project.id,
        equipe_domicile_id=team1.id,
        equipe_exterieur_id=team2.id,
        gymnase_id=venue.id,
        semaine=3,
        est_fixe=False
    )
    test_db.add(match1)
    test_db.commit()
    assert match1.est_modifiable(project.semaine_min) == True
    
    # Match fix√© : non modifiable
    match2 = Match(
        project_id=project.id,
        equipe_domicile_id=team1.id,
        equipe_exterieur_id=team2.id,
        gymnase_id=venue.id,
        semaine=4,
        est_fixe=True
    )
    test_db.add(match2)
    test_db.commit()
    assert match2.est_modifiable(project.semaine_min) == False
    
    # Match avant semaine_min : non modifiable
    match3 = Match(
        project_id=project.id,
        equipe_domicile_id=team1.id,
        equipe_exterieur_id=team2.id,
        gymnase_id=venue.id,
        semaine=1,  # < semaine_min (2)
        est_fixe=False
    )
    test_db.add(match3)
    test_db.commit()
    assert match3.est_modifiable(project.semaine_min) == False
```

**Points cl√©s** :
- **Test cr√©ation** : Valider stockage config_yaml_data, config_excel_data
- **Test cascade** : V√©rifier que supprimer Project supprime enfants (teams, venues, matches)
- **Test est_modifiable** : Logique False si est_fixe ou semaine < semaine_min

---

### Tests du service de synchronisation

**üìÅ Fichier √† cr√©er** : `backend/tests/test_sync_service.py`

**Contenu complet** :

```python
"""
Tests du service de synchronisation.
"""

import pytest
from backend.services.sync_service import SyncService
from backend.database.models import Project, Team, Venue, Match

def test_import_from_excel(test_db, config_yaml_file, config_excel_file):
    """Test import complet depuis YAML+Excel."""
    service = SyncService(test_db)
    
    # Modifier YAML pour r√©f√©rencer Excel
    yaml_content = config_yaml_file.read_text()
    yaml_content = yaml_content.replace(
        'donnees: "test_data.xlsx"',
        f'donnees: "{config_excel_file}"'
    )
    config_yaml_file.write_text(yaml_content)
    
    # Import
    project = service.import_from_excel(
        yaml_path=str(config_yaml_file),
        project_name="Test Import",
        validate_excel=False  # Pas de validation pour test (actualiser_config.py)
    )
    
    # V√©rifier project
    assert project.id is not None
    assert project.nom == "Test Import"
    assert project.sport == "Volleyball"
    assert project.nb_semaines == 10
    assert project.semaine_min == 2  # Depuis YAML (pas de d√©faut dans .py)
    assert project.config_yaml_path == str(config_yaml_file)
    assert project.config_excel_path == str(config_excel_file)
    
    # V√©rifier √©quipes (3 dans Excel fixture)
    teams = test_db.query(Team).filter_by(project_id=project.id).all()
    assert len(teams) == 3
    assert teams[0].institution in ["Lyc√©e A", "Lyc√©e B"]
    
    # V√©rifier gymnases (2 dans Excel fixture)
    venues = test_db.query(Venue).filter_by(project_id=project.id).all()
    assert len(venues) == 2
    assert venues[0].nom in ["Gymnase 1", "Gymnase 2"]
    
    # V√©rifier matchs g√©n√©r√©s
    matches = test_db.query(Match).filter_by(project_id=project.id).all()
    assert len(matches) > 0  # Au moins 1 match g√©n√©r√© (P1 : 3 √©quipes)

def test_import_validation_excel(test_db, config_yaml_file, config_excel_file):
    """Test validation Excel via actualiser_config.py (si disponible)."""
    service = SyncService(test_db)
    
    # Modifier YAML
    yaml_content = config_yaml_file.read_text()
    yaml_content = yaml_content.replace(
        'donnees: "test_data.xlsx"',
        f'donnees: "{config_excel_file}"'
    )
    config_yaml_file.write_text(yaml_content)
    
    # Test avec validate_excel=True
    # Note: actualiser_config.py doit exister et retourner 0 si Excel OK
    try:
        project = service.import_from_excel(
            yaml_path=str(config_yaml_file),
            project_name="Test Validation",
            validate_excel=True
        )
        # Si actualiser_config.py disponible et Excel OK
        assert project is not None
    except Exception as e:
        # Si actualiser_config.py indisponible ou Excel invalide
        assert "validation" in str(e).lower() or "actualiser_config" in str(e).lower()

def test_import_yaml_not_found(test_db):
    """Test erreur si fichier YAML introuvable."""
    service = SyncService(test_db)
    
    with pytest.raises(FileNotFoundError):
        service.import_from_excel(
            yaml_path="/inexistant/config.yaml",
            project_name="Test"
        )

def test_import_excel_not_found(test_db, config_yaml_file):
    """Test erreur si fichier Excel introuvable."""
    # YAML r√©f√©rence Excel inexistant
    yaml_content = config_yaml_file.read_text()
    yaml_content = yaml_content.replace(
        'donnees: "test_data.xlsx"',
        'donnees: "/inexistant/data.xlsx"'
    )
    config_yaml_file.write_text(yaml_content)
    
    service = SyncService(test_db)
    
    with pytest.raises(FileNotFoundError):
        service.import_from_excel(
            yaml_path=str(config_yaml_file),
            project_name="Test"
        )
```

**Points cl√©s** :
- **Test import complet** : V√©rifier cr√©ation project + teams + venues + matches
- **Test validation Excel** : Tester validate_excel=True (actualiser_config.py)
- **Test erreurs** : FileNotFoundError si YAML ou Excel manquant
- **V√©rification semaine_min** : Confirmer valeur depuis YAML (pas de d√©faut .py)

---

### Tests des routes API

**üìÅ Fichier √† cr√©er** : `backend/tests/test_api_matches.py`

**Contenu complet** :

```python
"""
Tests des routes API pour les matchs.
"""

import pytest
from backend.database.models import Project, Team, Venue, Match

@pytest.fixture
def setup_data(test_db):
    """Fixture pour cr√©er donn√©es de test."""
    # Project
    project = Project(nom="Test", sport="Volley", nb_semaines=10, semaine_min=2)
    test_db.add(project)
    test_db.commit()
    
    # Teams
    team1 = Team(project_id=project.id, nom="Team 1", institution="A", numero=1, niveau="M", categorie="G", poule="P1")
    team2 = Team(project_id=project.id, nom="Team 2", institution="B", numero=1, niveau="M", categorie="G", poule="P1")
    test_db.add_all([team1, team2])
    test_db.commit()
    
    # Venue
    venue = Venue(project_id=project.id, nom="Gym 1")
    test_db.add(venue)
    test_db.commit()
    
    # Match
    match = Match(
        project_id=project.id,
        equipe_domicile_id=team1.id,
        equipe_exterieur_id=team2.id,
        gymnase_id=venue.id,
        semaine=3,
        est_fixe=False
    )
    test_db.add(match)
    test_db.commit()
    
    return {
        "project": project,
        "team1": team1,
        "team2": team2,
        "venue": venue,
        "match": match
    }

def test_get_matches(client, setup_data):
    """Test GET /projects/{id}/matches."""
    project_id = setup_data["project"].id
    
    response = client.get(f"/projects/{project_id}/matches")
    assert response.status_code == 200
    
    data = response.json()
    assert len(data) == 1
    assert data[0]["semaine"] == 3
    assert data[0]["est_fixe"] == False

def test_move_match(client, setup_data):
    """Test POST /matches/{id}/move."""
    match_id = setup_data["match"].id
    
    # D√©placer vers semaine 5
    response = client.post(
        f"/matches/{match_id}/move",
        json={"nouvelle_semaine": 5}
    )
    assert response.status_code == 200
    
    data = response.json()
    assert data["semaine"] == 5

def test_move_match_non_modifiable(client, setup_data):
    """Test d√©placement impossible si match fix√© ou avant semaine_min."""
    match = setup_data["match"]
    match.est_fixe = True
    client.app.dependency_overrides[lambda: None]  # Forcer commit (hack test)
    
    # Tenter d√©placement
    response = client.post(
        f"/matches/{match.id}/move",
        json={"nouvelle_semaine": 6}
    )
    assert response.status_code == 400  # Bad Request
    assert "non modifiable" in response.json()["detail"].lower()

def test_fix_match(client, setup_data):
    """Test POST /matches/{id}/fix."""
    match_id = setup_data["match"].id
    
    response = client.post(f"/matches/{match_id}/fix")
    assert response.status_code == 200
    
    data = response.json()
    assert data["est_fixe"] == True

def test_unfix_match(client, setup_data):
    """Test POST /matches/{id}/unfix."""
    match = setup_data["match"]
    match.est_fixe = True
    
    response = client.post(f"/matches/{match.id}/unfix")
    assert response.status_code == 200
    
    data = response.json()
    assert data["est_fixe"] == False

def test_delete_match(client, setup_data):
    """Test DELETE /matches/{id}."""
    match_id = setup_data["match"].id
    
    response = client.delete(f"/matches/{match_id}")
    assert response.status_code == 204
    
    # V√©rifier suppression
    response = client.get(f"/matches/{match_id}")
    assert response.status_code == 404
```

**Points cl√©s** :
- **Fixture setup_data** : Cr√©er project + teams + venue + match
- **Test GET** : Lister matchs d'un projet
- **Test move** : D√©placer match vers nouvelle semaine
- **Test validation** : Erreur 400 si match non modifiable (fix√© ou semaine < semaine_min)
- **Test fix/unfix** : Fixer/d√©fixer match
- **Test delete** : Supprimer match (204 No Content)

---

### Tests des routes Projects

**üìÅ Fichier √† cr√©er** : `backend/tests/test_api_projects.py`

**Contenu complet** :

```python
"""
Tests des routes API pour les projets.
"""

import pytest

def test_create_project(client):
    """Test POST /projects."""
    payload = {
        "nom": "Nouveau Projet",
        "sport": "Handball",
        "nb_semaines": 12,
        "semaine_min": 3,
        "config_yaml_path": "/configs/handball.yaml",
        "config_excel_path": "/data/handball.xlsx",
        "config_yaml_data": {"sport": "Handball"},
        "config_excel_data": {"equipes": 10}
    }
    
    response = client.post("/projects", json=payload)
    assert response.status_code == 201
    
    data = response.json()
    assert data["nom"] == "Nouveau Projet"
    assert data["sport"] == "Handball"
    assert data["config_yaml_path"] == "/configs/handball.yaml"
    assert data["config_excel_data"]["equipes"] == 10

def test_get_projects(client, test_db):
    """Test GET /projects."""
    from backend.database.models import Project
    
    # Cr√©er 2 projects
    p1 = Project(nom="P1", sport="Volley", nb_semaines=5, semaine_min=1)
    p2 = Project(nom="P2", sport="Handball", nb_semaines=8, semaine_min=2)
    test_db.add_all([p1, p2])
    test_db.commit()
    
    response = client.get("/projects")
    assert response.status_code == 200
    
    data = response.json()
    assert len(data) == 2
    assert data[0]["nom"] in ["P1", "P2"]

def test_get_project_stats(client, test_db):
    """Test GET /projects/{id}/stats."""
    from backend.database.models import Project, Team, Match
    
    # Cr√©er project
    project = Project(nom="Test", sport="Volley", nb_semaines=10, semaine_min=2)
    test_db.add(project)
    test_db.commit()
    
    # Cr√©er √©quipes
    t1 = Team(project_id=project.id, nom="T1", institution="A", numero=1, niveau="M", categorie="G", poule="P1")
    t2 = Team(project_id=project.id, nom="T2", institution="B", numero=1, niveau="M", categorie="G", poule="P1")
    test_db.add_all([t1, t2])
    test_db.commit()
    
    # Cr√©er matchs
    m1 = Match(project_id=project.id, equipe_domicile_id=t1.id, equipe_exterieur_id=t2.id, semaine=3, est_fixe=True)
    m2 = Match(project_id=project.id, equipe_domicile_id=t1.id, equipe_exterieur_id=t2.id, semaine=None)  # Non planifi√©
    test_db.add_all([m1, m2])
    test_db.commit()
    
    # Requ√™te stats
    response = client.get(f"/projects/{project.id}/stats")
    assert response.status_code == 200
    
    data = response.json()
    assert data["nb_equipes"] == 2
    assert data["nb_matchs"] == 2
    assert data["nb_matchs_planifies"] == 1
    assert data["nb_matchs_fixes"] == 1

def test_delete_project_cascade(client, test_db):
    """Test DELETE /projects/{id} avec cascade."""
    from backend.database.models import Project, Team, Match
    
    # Cr√©er project + team + match
    project = Project(nom="Delete Test", sport="Volley", nb_semaines=5, semaine_min=1)
    test_db.add(project)
    test_db.commit()
    
    team = Team(project_id=project.id, nom="T1", institution="A", numero=1, niveau="M", categorie="G", poule="P1")
    test_db.add(team)
    test_db.commit()
    
    match = Match(project_id=project.id, equipe_domicile_id=team.id, equipe_exterieur_id=team.id, semaine=2)
    test_db.add(match)
    test_db.commit()
    
    project_id = project.id
    
    # Supprimer project
    response = client.delete(f"/projects/{project_id}")
    assert response.status_code == 204
    
    # V√©rifier cascade
    assert test_db.query(Team).filter_by(project_id=project_id).count() == 0
    assert test_db.query(Match).filter_by(project_id=project_id).count() == 0
```

**Points cl√©s** :
- **Test cr√©ation** : Valider stockage config_yaml_data, config_excel_data
- **Test liste** : GET /projects retourne tous les projets
- **Test stats** : V√©rifier calculs nb_equipes, nb_matchs, nb_matchs_planifies, nb_matchs_fixes
- **Test cascade delete** : Supprimer project supprime teams et matches

---

### Configuration coverage

**üìÅ Fichier √† cr√©er** : `backend/tests/.coveragerc`

**Contenu** :

```ini
[run]
source = backend
omit =
    */tests/*
    */venv/*
    */__pycache__/*
    */migrations/*

[report]
precision = 2
show_missing = True
skip_covered = False

[html]
directory = htmlcov
```

**üìÅ Fichier √† cr√©er** : `backend/pytest.ini`

**Contenu** :

```ini
[pytest]
testpaths = backend/tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --verbose
    --cov=backend
    --cov-report=term-missing
    --cov-report=html
```

---

### Script d'ex√©cution des tests

**üìÅ Fichier √† cr√©er** : `scripts/run_tests.sh`

**Contenu** :

```bash
#!/bin/bash

# Script pour ex√©cuter les tests backend avec coverage

echo "========================================="
echo "PyCalendar - Tests Unitaires Backend"
echo "========================================="

# Activer environnement virtuel si disponible
if [ -d "venv" ]; then
    source venv/bin/activate
fi

# Installer d√©pendances de test si n√©cessaire
echo ""
echo "üì¶ V√©rification des d√©pendances..."
pip install -q pytest pytest-cov pandas openpyxl fastapi httpx

# Ex√©cuter tests
echo ""
echo "üß™ Ex√©cution des tests..."
pytest backend/tests/ \
    --verbose \
    --cov=backend \
    --cov-report=term-missing \
    --cov-report=html \
    --tb=short

# Afficher r√©sum√© coverage
echo ""
echo "========================================="
echo "üìä Rapport de couverture g√©n√©r√© : htmlcov/index.html"
echo "========================================="

# Ouvrir rapport HTML si possible (Linux)
if command -v xdg-open &> /dev/null; then
    xdg-open htmlcov/index.html
fi
```

**Rendre ex√©cutable** :
```bash
chmod +x scripts/run_tests.sh
```

**Usage** :
```bash
./scripts/run_tests.sh
```

---

### Consignes d'organisation

**Structure des tests** :
```
backend/tests/
‚îú‚îÄ‚îÄ conftest.py                # Fixtures partag√©es (test_db, client, configs)
‚îú‚îÄ‚îÄ test_models.py             # Tests mod√®les SQLAlchemy
‚îú‚îÄ‚îÄ test_sync_service.py       # Tests SyncService (import YAML+Excel)
‚îú‚îÄ‚îÄ test_api_projects.py       # Tests routes /projects
‚îú‚îÄ‚îÄ test_api_matches.py        # Tests routes /matches
‚îú‚îÄ‚îÄ test_api_teams.py          # Tests routes /teams (√† cr√©er)
‚îú‚îÄ‚îÄ test_api_venues.py         # Tests routes /venues (√† cr√©er)
‚îú‚îÄ‚îÄ .coveragerc                # Config coverage
‚îî‚îÄ‚îÄ pytest.ini                 # Config pytest
```

**Bonnes pratiques** :
1. **Fixtures scope="function"** : Isolation totale entre tests
2. **DB en m√©moire** : Rapidit√© (sqlite:///:memory:)
3. **Nommage clair** : test_<action>_<scenario> (ex: test_move_match_non_modifiable)
4. **Assertions explicites** : assert data["nb_equipes"] == 2 (pas juste assert data)
5. **Cleanup automatique** : yield dans fixtures + tempfile pour fichiers temporaires

**Couverture cible** :
- **Mod√®les** : 100% (simples, pas de logique complexe)
- **Services** : > 80% (import, validation, g√©n√©ration)
- **Routes API** : > 90% (CRUD complet, erreurs)
- **Total** : > 80%

---

## √Ä faire/v√©rifier

**Checklist de d√©veloppement** :

1. ‚úÖ Cr√©er `backend/tests/conftest.py` avec :
   - Fixture test_db (DB en m√©moire)
   - Fixture client (TestClient FastAPI)
   - Fixtures config_yaml_file et config_excel_file (7 feuilles)

2. ‚úÖ Cr√©er `backend/tests/test_models.py` avec :
   - test_create_project (config_yaml_data, config_excel_data)
   - test_create_team
   - test_cascade_delete_project
   - test_match_modifiable_logic

3. ‚úÖ Cr√©er `backend/tests/test_sync_service.py` avec :
   - test_import_from_excel (complet, v√©rifier teams/venues/matches)
   - test_import_validation_excel (actualiser_config.py)
   - test_import_yaml_not_found
   - test_import_excel_not_found

4. ‚úÖ Cr√©er `backend/tests/test_api_matches.py` avec :
   - test_get_matches
   - test_move_match
   - test_move_match_non_modifiable
   - test_fix_match, test_unfix_match
   - test_delete_match

5. ‚úÖ Cr√©er `backend/tests/test_api_projects.py` avec :
   - test_create_project
   - test_get_projects
   - test_get_project_stats
   - test_delete_project_cascade

6. ‚úÖ Cr√©er configs pytest :
   - `backend/tests/.coveragerc`
   - `backend/pytest.ini`
   - `scripts/run_tests.sh`

**Checklist de validation** :

1. ‚úÖ **Ex√©cuter tests** :
   ```bash
   # Installer d√©pendances
   pip install pytest pytest-cov pandas openpyxl httpx
   
   # Ex√©cuter tous les tests
   pytest backend/tests/ -v
   
   # Avec coverage
   pytest backend/tests/ --cov=backend --cov-report=term-missing
   ```

2. ‚úÖ **V√©rifier couverture** :
   ```bash
   # G√©n√©rer rapport HTML
   pytest backend/tests/ --cov=backend --cov-report=html
   
   # Ouvrir htmlcov/index.html
   xdg-open htmlcov/index.html
   ```

3. ‚úÖ **Tests sp√©cifiques** :
   ```bash
   # Tests mod√®les uniquement
   pytest backend/tests/test_models.py -v
   
   # Tests API uniquement
   pytest backend/tests/test_api_*.py -v
   
   # Test sp√©cifique
   pytest backend/tests/test_sync_service.py::test_import_from_excel -v
   ```

4. ‚úÖ **V√©rifier fixtures** :
   ```bash
   # Lister fixtures disponibles
   pytest backend/tests/ --fixtures
   ```

5. ‚úÖ **Tests avec script** :
   ```bash
   ./scripts/run_tests.sh
   ```

**Commandes de test rapide** :
```bash
# Test rapide (sans coverage)
pytest backend/tests/ -v

# Test avec coverage minimal
pytest backend/tests/ --cov=backend --cov-report=term

# Test un fichier
pytest backend/tests/test_models.py -v

# Test une fonction
pytest backend/tests/test_sync_service.py::test_import_from_excel -vv
```

---

## Questions

**Questions critiques √† poser si quelque chose n'est pas clair** :

1. **Validation Excel dans tests** :
   - Faut-il mocker `actualiser_config.py` dans les tests (subprocess.run) ?
   - Ou cr√©er un Excel fixture toujours valide et tester validate_excel=False ?
   - Faut-il tester les erreurs d'`actualiser_config.py` (retour != 0) ?

2. **Fixtures YAML/Excel** :
   - Les 7 feuilles Excel dans la fixture sont-elles suffisantes ?
   - Faut-il ajouter des colonnes sp√©cifiques (Horaires_Matchs, Cr√©neaux_Disponibles) ?
   - Les donn√©es de test (3 √©quipes, 2 gymnases) sont-elles repr√©sentatives ?

3. **Tests SyncService** :
   - Faut-il tester la g√©n√©ration de matchs en d√©tail (poules, aller-retour) ?
   - Ou simplement v√©rifier que len(matches) > 0 ?
   - Faut-il tester les contraintes appliqu√©es (indispos, pr√©f√©rences) ?

4. **Tests API** :
   - Faut-il tester tous les codes d'erreur (400, 404, 422) ?
   - Faut-il tester la validation Pydantic (types, champs requis) ?
   - Faut-il tester les routes /teams et /venues en d√©tail ?

5. **Couverture** :
   - Objectif de couverture : 80%, 90%, 100% ?
   - Faut-il exclure certains fichiers (scripts/, actualiser_config.py) ?
   - Faut-il un rapport coverage dans CI/CD (GitHub Actions) ?

6. **Performance** :
   - Les tests sont-ils assez rapides (< 10s total) ?
   - Faut-il optimiser les fixtures (scope="session" pour configs) ?
   - Faut-il parall√©liser les tests (pytest-xdist) ?

---

## Documentation

Rester concis : documenter uniquement les choix non √©vidents :
- **DB en m√©moire** : Expliquer pourquoi sqlite:///:memory: (isolation, rapidit√©)
- **Override get_db** : Expliquer injection d√©pendance FastAPI dans tests
- **Fixtures temporaires** : Expliquer tempfile + cleanup automatique
- **Test est_modifiable** : Expliquer logique m√©tier (fix√© ou semaine < semaine_min)

√âviter la sur-documentation des concepts pytest/coverage standards.
