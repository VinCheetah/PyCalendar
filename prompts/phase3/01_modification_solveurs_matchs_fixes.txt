# Prompt 3.1 : Modification des Solveurs pour Matchs Fixes# Prompt 3.1 : Modification des solveurs ‚Äì Gestion matchs fixes



## Contexte global## Contexte global

PyCalendar V2 doit respecter les matchs fixes d√©finis par l'utilisateur via l'interface web. Les solveurs (optimal, heuristique) ne doivent PAS modifier ces matchs lors de l'optimisation.PyCalendar V2 int√®gre des solveurs d'optimisation (CP-SAT, Greedy) pour planifier les matchs sportifs. L'architecture doit permettre l'ajout de nouvelles contraintes, la gestion des matchs fixes (non replanifiables) et la maintenance des algorithmes existants sans r√©gression.



**RAPPEL - Double configuration et matchs fixes** :## Contexte technique

- **Matchs fixes** : D√©finis via UI web (POST /matches/{id}/fix), pas depuis Excel initialCette t√¢che concerne la modification des solveurs CP-SAT et Greedy pour prendre en compte les matchs fixes (non replanifiables) et la contrainte semaine_min dans la logique d'optimisation.

- **est_fixe = true** : Le solveur DOIT conserver semaine, gymnase, horaire

- **semaine_minimum** (YAML) : Premi√®re semaine modifiable par le solver## R√©sum√© du travail pr√©c√©dent

- **Matchs semaine < semaine_minimum** : Non modifiables, trait√©s comme fixes- Les solveurs sont en place et fonctionnent avec les contraintes de base (`solvers/cpsat_solver.py`, `solvers/greedy_solver.py`).

- La gestion des matchs fixes a √©t√© ajout√©e au mod√®le m√©tier (`core/models.py` : champs `est_fixe`, `statut`, m√©thode `est_modifiable()`).

## Contexte technique- La contrainte `semaine_min` a √©t√© ajout√©e √† la configuration (`core/config.py`).

Cette t√¢che modifie les solveurs existants pour respecter les contraintes de matchs fixes et semaine_minimum sans casser le code existant.- Le backend et l'API sont op√©rationnels.



## R√©sum√© du travail pr√©c√©dent## Objectifs

- Solveurs existants : optimal (CP-SAT), heuristique (T√¢che originale)- Adapter les solveurs pour filtrer et respecter les matchs fixes.

- G√©n√©rateurs de matchs : MultiPoolGenerator (pr√©serve code existant)- Int√©grer la contrainte semaine_min dans la g√©n√©ration des cr√©neaux disponibles.

- Mod√®le Match avec champ est_fixe (T√¢che 1.3)- S'assurer de la robustesse, de l'extensibilit√© et de la non-r√©gression du code.

- Config charge semaine_minimum depuis YAML (T√¢che 1.2)- Pr√©server la signature des m√©thodes et l'architecture existante.



## Objectifs## D√©tails techniques

1. Identifier matchs fixes dans les solveurs

2. Ajouter contraintes pour pr√©server matchs fixes### Fichiers √† modifier

3. Respecter semaine_minimum (filtrer matchs modifiables)- `solvers/cpsat_solver.py` : m√©thode `CPSATSolver.solve()`

4. NE PAS casser le code existant (solvers/, constraints/)- `solvers/greedy_solver.py` : m√©thode `GreedySolver.solve()`

5. Documenter modifications minimales

### Algorithme de modification (CP-SAT Solver)

## D√©tails techniques

**M√©thode concern√©e** : `CPSATSolver.solve(matchs, creneaux, gymnases)`

### Analyse du code existant

**Modifications √† apporter au d√©but de la m√©thode (avant cr√©ation model CP-SAT)** :

**üìÅ Fichiers concern√©s** :

- `solvers/optimal.py` : Solveur CP-SAT avec contraintes OR-Tools1. **S√©parer matchs fixes et modifiables** :

- `solvers/heuristique.py` : Solveur heuristique   ```python

- `constraints/` : Contraintes existantes (repos, domicile/ext√©rieur, etc.)   matchs_fixes = [m for m in matchs if m.est_fixe or m.statut == "fixe"]

   matchs_modifiables = [m for m in matchs if m.est_modifiable()]

**Principe de modification** :   ```

1. **Filtrer matchs modifiables** : Exclure matchs fixes et semaine < semaine_minimum

2. **Ajouter contraintes fixes** : Forcer assignment des matchs fixes2. **Identifier cr√©neaux r√©serv√©s par matchs fixes** :

3. **Pr√©server comportement** : Ne modifier que le n√©cessaire   ```python

   creneaux_reserves = set()

---   for m in matchs_fixes:

       if m.creneau:

### Modification du solveur optimal (CP-SAT)           creneaux_reserves.add((m.creneau.semaine, m.creneau.horaire, m.creneau.gymnase))

       else:

**üìÅ Fichier √† modifier** : `solvers/optimal.py`           # Log warning : match fix√© sans cr√©neau

           print(f"Warning: Match fix√© {m.id} sans cr√©neau assign√©")

**√âtape 1 : Identifier matchs fixes et modifiables**   ```



**Localisation** : D√©but de la fonction `solve()` ou `run()`3. **Filtrer cr√©neaux disponibles** :

   ```python

**Ajout de code** :   creneaux_disponibles = [

       c for c in creneaux 

```python       if (c.semaine, c.horaire, c.gymnase) not in creneaux_reserves

def solve(self, config, matchs, equipes, gymnases):   ]

    """   ```

    R√©sout le probl√®me de planification avec CP-SAT.

    4. **Appliquer contrainte semaine_min** :

    IMPORTANT : Respecte les matchs fixes (est_fixe=True) et semaine_minimum.   ```python

    """   semaine_min = getattr(self.config, 'semaine_min', 1)

    from ortools.sat.python import cp_model   creneaux_disponibles = [

           c for c in creneaux_disponibles 

    model = cp_model.CpModel()       if c.semaine >= semaine_min

       ]

    # NOUVEAU : R√©cup√©rer semaine_minimum depuis config   ```

    semaine_minimum = config.semaines.get('semaine_minimum', 1)

    5. **R√©soudre avec matchs_modifiables et creneaux_disponibles** :

    # NOUVEAU : S√©parer matchs fixes et modifiables   - Toute la logique existante du solver CP-SAT

    matchs_fixes = []   - Ne cr√©er variables CP-SAT que pour `matchs_modifiables`

    matchs_modifiables = []   - Ne consid√©rer que `creneaux_disponibles`

    

    for match in matchs:6. **Apr√®s r√©solution, reconstruire solution compl√®te** :

        # Un match est fixe si :   ```python

        # 1. est_fixe = True (fix√© via UI web)   # Apr√®s extraction de la solution

        # 2. semaine < semaine_minimum (matchs d√©j√† jou√©s/planifi√©s)   # Ajouter matchs fixes √† la solution

        if match.est_fixe or (match.semaine is not None and match.semaine < semaine_minimum):   for m in matchs_fixes:

            matchs_fixes.append(match)       if m.creneau:

        else:           solution.matchs_planifies.append(m)

            matchs_modifiables.append(match)   

       # solution contient maintenant matchs fixes + matchs r√©solus

    print(f"[Solveur Optimal] {len(matchs_fixes)} matchs fixes, {len(matchs_modifiables)} modifiables")   ```

    

    # Suite du code existant...### Algorithme de modification (Greedy Solver)

    # Ne cr√©er des variables CP-SAT QUE pour matchs_modifiables

```**M√©thode concern√©e** : `GreedySolver.solve(matchs, creneaux, gymnases)`



**Points cl√©s** :**Appliquer la m√™me logique de filtrage** :

- **semaine_minimum** : R√©cup√©r√© depuis `config.semaines['semaine_minimum']`- S√©parer matchs fixes et modifiables

- **Filtrage** : Match fixe si `est_fixe=True` OU `semaine < semaine_minimum`- Identifier cr√©neaux r√©serv√©s

- **Logging** : Afficher nombre de matchs fixes vs modifiables- Filtrer cr√©neaux disponibles

- Appliquer semaine_min

---- R√©soudre avec matchs_modifiables

- Reconstruire solution avec matchs fixes

**√âtape 2 : Cr√©er variables CP-SAT uniquement pour matchs modifiables**

### Consignes d'organisation

**Localisation** : Boucle de cr√©ation des variables (probablement une boucle `for match in matchs`)- **NE PAS modifier** la signature de la m√©thode `solve()`

- **Pr√©server** toute la logique existante du solver (juste filtrer les inputs)

**Modification** :- **V√©rifier** que les matchs fixes ont un cr√©neau valide (log warning sinon)

- **Utiliser** la m√©thode `est_modifiable()` ajout√©e en Phase 1

```python- **Tester** la non-r√©gression : les solveurs doivent toujours fonctionner sans matchs fixes

# AVANT (code existant √† remplacer)

# for match in matchs:### Impact et liens

#     match_vars[match.id] = {}- Le service solveur (`backend/services/solver_service.py`) appellera ces m√©thodes modifi√©es.

#     for semaine in range(1, config.nb_semaines + 1):- Les matchs fixes seront cr√©√©s via l'API (`backend/api/routes/matches.py` : endpoints fix/unfix).

#         match_vars[match.id][semaine] = model.NewBoolVar(f'match_{match.id}_semaine_{semaine}')- La solution retourn√©e contiendra √† la fois matchs fixes et matchs planifi√©s.



# APR√àS (nouveau code)## √Ä faire/v√©rifier

match_vars = {}- Modifier `CPSATSolver.solve()` selon l'algorithme d√©crit

- Modifier `GreedySolver.solve()` selon le m√™me pattern

# 1. Cr√©er variables SEULEMENT pour matchs modifiables- V√©rifier la logique de filtrage :

for match in matchs_modifiables:  - Matchs fixes correctement identifi√©s

    match_vars[match.id] = {}  - Cr√©neaux r√©serv√©s bien exclus

    for semaine in range(semaine_minimum, config.nb_semaines + 1):  # Commencer √† semaine_minimum  - Contrainte semaine_min appliqu√©e

        match_vars[match.id][semaine] = model.NewBoolVar(f'match_{match.id}_semaine_{semaine}')- Tester avec donn√©es mixtes :

  - Cr√©er 10 matchs, fixer 3 d'entre eux sur diff√©rents cr√©neaux

# 2. Pour matchs fixes : NE PAS cr√©er de variables, simplement les conserver  - Lancer solver

# (ils seront r√©int√©gr√©s √† la fin sans modification)  - V√©rifier que :

```    - Les 3 matchs fixes restent inchang√©s

    - Les 7 autres sont planifi√©s sans conflit

**Points cl√©s** :    - Aucun match n'est assign√© aux cr√©neaux des matchs fixes

- **range(semaine_minimum, ...)** : Ne planifier qu'√† partir de semaine_minimum- Tester semaine_min :

- **Pas de variables pour fixes** : Matchs fixes ne sont PAS dans le mod√®le CP-SAT  - Config avec `semaine_min: 5`

- **R√©int√©gration finale** : Matchs fixes ajout√©s √† la solution sans changement  - V√©rifier qu'aucun match n'est planifi√© avant semaine 5

- Tester la non-r√©gression :

---  - Lancer solver sans matchs fixes ‚Üí doit fonctionner comme avant



**√âtape 3 : Ajouter contraintes pour respecter matchs fixes**## Questions

Poser des questions si des points sur la logique d'optimisation, le filtrage, l'int√©gration ou la non-r√©gression ne sont pas clairs.

**Localisation** : Section des contraintes (probablement apr√®s cr√©ation des variables)

## Documentation

**Ajout de code** :Rester concis, ne pas ajouter de documentation excessive. Commenter bri√®vement la logique de filtrage dans le code si besoin.


```python
# NOUVEAU : Contraintes pour √©viter conflits avec matchs fixes
for match_fixe in matchs_fixes:
    # Si match fixe utilise une √©quipe, cette √©quipe ne peut pas jouer ailleurs cette semaine
    for match_mod in matchs_modifiables:
        if (match_fixe.equipe_domicile_id == match_mod.equipe_domicile_id or
            match_fixe.equipe_domicile_id == match_mod.equipe_exterieur_id or
            match_fixe.equipe_exterieur_id == match_mod.equipe_domicile_id or
            match_fixe.equipe_exterieur_id == match_mod.equipe_exterieur_id):
            
            # Interdire au match modifiable d'√™tre √† la m√™me semaine que le match fixe
            if match_fixe.semaine in match_vars.get(match_mod.id, {}):
                model.Add(match_vars[match_mod.id][match_fixe.semaine] == 0)
    
    # Si match fixe utilise un gymnase, ce gymnase ne peut pas √™tre utilis√© ailleurs cette semaine
    # (cette contrainte peut d√©j√† exister dans le code, v√©rifier pour √©viter duplication)
```

**Points cl√©s** :
- **√âviter conflits √©quipes** : Une √©quipe ne peut pas jouer 2 matchs la m√™me semaine
- **√âviter conflits gymnases** : Un gymnase ne peut pas accueillir 2 matchs simultan√©ment
- **V√©rifier code existant** : Ces contraintes existent peut-√™tre d√©j√†, adapter si n√©cessaire

---

**√âtape 4 : R√©int√©grer matchs fixes dans la solution**

**Localisation** : Fin de la fonction, apr√®s r√©solution du mod√®le

**Modification** :

```python
# R√©soudre le mod√®le CP-SAT (code existant)
solver = cp_model.CpSolver()
status = solver.Solve(model)

if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
    # Extraire solution pour matchs modifiables (code existant)
    solution = []
    for match in matchs_modifiables:
        for semaine in range(semaine_minimum, config.nb_semaines + 1):
            if solver.Value(match_vars[match.id][semaine]) == 1:
                solution.append({
                    'match_id': match.id,
                    'semaine': semaine,
                    'gymnase_id': match.gymnase_id,  # Ou extrait du mod√®le
                })
    
    # NOUVEAU : Ajouter matchs fixes √† la solution SANS modification
    for match_fixe in matchs_fixes:
        solution.append({
            'match_id': match_fixe.id,
            'semaine': match_fixe.semaine,
            'gymnase_id': match_fixe.gymnase_id,
            'est_fixe': True,  # Marqueur pour indiquer que c'est un match fixe
        })
    
    return solution
else:
    raise ValueError("Aucune solution trouv√©e par le solveur optimal")
```

**Points cl√©s** :
- **Solution = modifiables + fixes** : Combiner les deux listes
- **Conserver valeurs fixes** : semaine, gymnase_id inchang√©s
- **Marqueur est_fixe** : Optionnel, pour debug/logging

---

### Modification du solveur heuristique

**üìÅ Fichier √† modifier** : `solvers/heuristique.py`

**Principe identique** :

1. **Filtrer matchs** :
```python
def solve(self, config, matchs, equipes, gymnases):
    semaine_minimum = config.semaines.get('semaine_minimum', 1)
    
    matchs_fixes = [m for m in matchs if m.est_fixe or (m.semaine and m.semaine < semaine_minimum)]
    matchs_modifiables = [m for m in matchs if m not in matchs_fixes]
    
    # Suite heuristique sur matchs_modifiables uniquement...
```

2. **√âviter conflits** :
```python
def is_valid_assignment(self, match, semaine, matchs_fixes):
    # V√©rifier qu'aucun match fixe n'utilise la m√™me √©quipe cette semaine
    for match_fixe in matchs_fixes:
        if match_fixe.semaine == semaine:
            if (match.equipe_domicile_id in [match_fixe.equipe_domicile_id, match_fixe.equipe_exterieur_id] or
                match.equipe_exterieur_id in [match_fixe.equipe_domicile_id, match_fixe.equipe_exterieur_id]):
                return False
    return True
```

3. **R√©int√©grer matchs fixes** :
```python
# √Ä la fin
solution_complete = solution_heuristique + [
    {'match_id': m.id, 'semaine': m.semaine, 'gymnase_id': m.gymnase_id}
    for m in matchs_fixes
]
return solution_complete
```

---

### Modification des contraintes existantes

**üìÅ Fichiers √† v√©rifier** : `constraints/*.py`

**Principe** : Adapter les contraintes pour ignorer matchs fixes

**Exemple avec contrainte de repos** :

```python
# constraints/repos.py

def apply(self, model, match_vars, matchs, config):
    """
    Contrainte : Respecter temps de repos entre matchs d'une √©quipe.
    
    IMPORTANT : Ne s'applique QU'aux matchs modifiables.
    Les matchs fixes sont d√©j√† respect√©s par construction.
    """
    semaine_minimum = config.semaines.get('semaine_minimum', 1)
    
    # Filtrer matchs modifiables (ceux qui ont des variables dans match_vars)
    matchs_modifiables = [m for m in matchs if m.id in match_vars]
    
    # Appliquer contrainte uniquement sur matchs modifiables
    for equipe in equipes:
        matchs_equipe = [m for m in matchs_modifiables if 
                        m.equipe_domicile_id == equipe.id or 
                        m.equipe_exterieur_id == equipe.id]
        
        # Contrainte de repos (code existant)
        # ...
```

**Points cl√©s** :
- **Filtrer par match_vars** : Si match.id pas dans match_vars, c'est un match fixe
- **Ne PAS modifier contraintes si d√©j√† OK** : V√©rifier d'abord le code existant
- **√âviter duplication** : Les contraintes existantes g√®rent peut-√™tre d√©j√† correctement

---

### Validation et tests

**üìÅ Fichier de test √† cr√©er** : `tests/test_solveur_matchs_fixes.py`

**Contenu** :

```python
import pytest
from solvers.optimal import OptimalSolver
from core.config import Config

def test_respect_matchs_fixes():
    """Test que le solveur respecte les matchs fixes."""
    
    # Config avec semaine_minimum = 3
    config = Config(
        sport="Volleyball",
        nb_semaines=10,
        semaines={'semaine_minimum': 3},
        # ... autres params
    )
    
    # Matchs avec 2 fixes
    matchs = [
        Match(id=1, equipe_domicile_id=1, equipe_exterieur_id=2, semaine=2, est_fixe=False),  # < semaine_min : fixe
        Match(id=2, equipe_domicile_id=3, equipe_exterieur_id=4, semaine=5, est_fixe=True),   # Fix√© via UI
        Match(id=3, equipe_domicile_id=5, equipe_exterieur_id=6, semaine=None, est_fixe=False), # Modifiable
    ]
    
    solver = OptimalSolver()
    solution = solver.solve(config, matchs, equipes, gymnases)
    
    # V√©rifier que matchs fixes n'ont PAS chang√©
    assert any(s['match_id'] == 1 and s['semaine'] == 2 for s in solution)
    assert any(s['match_id'] == 2 and s['semaine'] == 5 for s in solution)
    
    # V√©rifier que match modifiable a √©t√© planifi√© (>= semaine_minimum)
    match3_sol = [s for s in solution if s['match_id'] == 3][0]
    assert match3_sol['semaine'] >= 3

def test_eviter_conflits_equipes():
    """Test qu'un match fixe emp√™che l'√©quipe de jouer ailleurs la m√™me semaine."""
    
    matchs = [
        Match(id=1, equipe_domicile_id=1, equipe_exterieur_id=2, semaine=3, est_fixe=True),
        Match(id=2, equipe_domicile_id=1, equipe_exterieur_id=3, semaine=None, est_fixe=False),  # M√™me √©quipe 1
    ]
    
    solver = OptimalSolver()
    solution = solver.solve(config, matchs, equipes, gymnases)
    
    # Match 2 NE DOIT PAS √™tre √† la semaine 3 (conflit avec match 1)
    match2_sol = [s for s in solution if s['match_id'] == 2][0]
    assert match2_sol['semaine'] != 3
```

---

## √Ä faire/v√©rifier

**Checklist de d√©veloppement** :

1. ‚úÖ **Analyser code existant** :
   ```bash
   # Lire solveur optimal
   cat solvers/optimal.py | head -100
   
   # Lire solveur heuristique
   cat solvers/heuristique.py | head -100
   
   # Lister contraintes
   ls -la constraints/
   ```

2. ‚úÖ **Modifier solveur optimal** :
   - Filtrer matchs fixes (est_fixe=True ou semaine < semaine_minimum)
   - Cr√©er variables CP-SAT seulement pour matchs modifiables
   - Ajouter contraintes pour √©viter conflits avec matchs fixes
   - R√©int√©grer matchs fixes dans solution finale

3. ‚úÖ **Modifier solveur heuristique** :
   - M√™me principe de filtrage
   - Adapter fonction is_valid_assignment
   - R√©int√©grer matchs fixes

4. ‚úÖ **V√©rifier contraintes existantes** :
   - constraints/repos.py
   - constraints/domicile_exterieur.py
   - constraints/indisponibilites.py
   - Adapter si n√©cessaire pour ignorer matchs fixes

5. ‚úÖ **Cr√©er tests** :
   - test_respect_matchs_fixes()
   - test_eviter_conflits_equipes()
   - test_semaine_minimum()

**Checklist de validation** :

1. ‚úÖ **Test solveur optimal** :
   ```bash
   # Ex√©cuter avec matchs fixes
   python -m pytest tests/test_solveur_matchs_fixes.py::test_respect_matchs_fixes -v
   ```

2. ‚úÖ **Test solveur heuristique** :
   ```bash
   pytest tests/test_solveur_matchs_fixes.py -v
   ```

3. ‚úÖ **Test int√©gration** :
   ```bash
   # Importer projet avec semaine_minimum = 3
   python scripts/import_excel.py configs/config_volley.yaml
   
   # Fixer un match via API
   curl -X POST http://localhost:8000/matches/1/fix
   
   # Lancer solveur
   # (via endpoint API cr√©√© en T√¢che 3.3)
   ```

4. ‚úÖ **V√©rifier logs** :
   ```bash
   # V√©rifier affichage "X matchs fixes, Y modifiables"
   grep "matchs fixes" logs/solver.log
   ```

**Commandes de test rapide** :
```bash
# Lancer tests solveur
pytest tests/test_solveur_matchs_fixes.py -v

# Test avec vraies donn√©es
python scripts/import_excel.py configs/config_volley.yaml
python -c "from solvers.optimal import OptimalSolver; print(OptimalSolver().solve(...))"
```

---

## Questions

**Questions critiques √† poser si quelque chose n'est pas clair** :

1. **Structure solveurs** :
   - Les solveurs ont-ils d√©j√† une m√©thode `solve(config, matchs, equipes, gymnases)` ?
   - Ou la signature est diff√©rente (ex: `run(data)`) ?
   - Y a-t-il une classe abstraite `BaseSolver` √† respecter ?

2. **Variables CP-SAT** :
   - Les variables sont-elles cr√©√©es avec `NewBoolVar` (bool√©ennes) ?
   - Y a-t-il des variables pour gymnases, horaires (en plus de semaines) ?
   - Faut-il modifier ces variables aussi pour matchs fixes ?

3. **Contraintes existantes** :
   - Les contraintes sont-elles dans des fichiers s√©par√©s (`constraints/`) ?
   - Sont-elles appel√©es automatiquement ou manuellement ?
   - Y a-t-il une factory/registry de contraintes ?

4. **Matchs fixes et gymnases** :
   - Un match fixe a-t-il TOUJOURS un gymnase assign√© ?
   - Ou peut-il √™tre fix√© en semaine mais sans gymnase (gymnase_id = null) ?
   - Faut-il traiter ce cas sp√©cial ?

5. **semaine_minimum** :
   - La valeur par d√©faut est-elle 1 ou 0 ?
   - Faut-il valider que semaine_minimum <= nb_semaines ?
   - Que faire si un match fixe est √† une semaine > nb_semaines (erreur) ?

6. **Performance** :
   - Filtrer les matchs r√©duit-il significativement le temps de r√©solution ?
   - Faut-il logger les performances (temps avant/apr√®s) ?
   - Y a-t-il un timeout √† respecter (temps_max_secondes) ?

---

## Documentation

Rester concis : documenter uniquement les choix non √©vidents :
- **Filtrage matchs** : Expliquer crit√®re `est_fixe=True OU semaine < semaine_minimum`
- **Pas de variables CP-SAT pour fixes** : Expliquer pourquoi (r√©duction espace recherche)
- **R√©int√©gration finale** : Expliquer combinaison matchs modifiables + fixes
- **Contraintes conflits** : Expliquer pourquoi emp√™cher √©quipe de jouer 2 fois m√™me semaine

√âviter la sur-documentation des concepts OR-Tools/CP-SAT standards.
