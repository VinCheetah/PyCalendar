# Prompt 3.3 : Endpoint API pour R√©solution# Prompt 3.3 : Endpoint API ‚Äì R√©solution projet



## Contexte global## Contexte global

PyCalendar V2 expose un endpoint API FastAPI pour d√©clencher la r√©solution d'un projet via le solveur. L'endpoint doit utiliser SolverService, respecter les matchs fixes, et retourner les r√©sultats.PyCalendar V2 doit permettre de lancer la r√©solution d'un projet via une API REST. L'endpoint doit √™tre clair, s√©curis√© et facilement extensible pour supporter diff√©rentes strat√©gies de r√©solution ou options de configuration.



**RAPPEL - Double configuration et r√©solution** :## Contexte technique

- **Strat√©gie solver** : Depuis config_yaml_data.solver.strategie ("optimal", "heuristique", "hybride")Cette t√¢che concerne la cr√©ation d'un endpoint API FastAPI permettant de lancer le solveur sur un projet donn√© et de r√©cup√©rer les r√©sultats (nombre de matchs planifi√©s, dur√©e, etc.).

- **Matchs fixes** : Pr√©serv√©s par SolverService (T√¢che 3.2)

- **R√©sultat** : Mise √† jour des matchs en DB (semaines, gymnases assign√©s)## R√©sum√© du travail pr√©c√©dent

- Le service Solveur est op√©rationnel (`backend/services/solver_service.py`).

## Contexte technique- Les solveurs sont modifi√©s pour g√©rer les matchs fixes (`solvers/`).

Cette t√¢che cr√©e les routes API FastAPI pour r√©soudre un projet, r√©cup√©rer le statut de r√©solution, et annuler une r√©solution en cours.- Le backend g√®re les entit√©s et l'API REST (`backend/api/routes/`).



## R√©sum√© du travail pr√©c√©dent## Objectifs

- SolverService cr√©√© (T√¢che 3.2)- Cr√©er un endpoint API clair et s√©curis√© pour la r√©solution de projets.

- Routes API projects, matches cr√©√©es (T√¢che 1.5)- S'assurer de la robustesse, de la gestion des erreurs et de la clart√© du code.

- Sch√©mas Pydantic ProjectResponse, MatchResponse (T√¢che 1.4)- Pr√©voir l'√©volution pour d'autres solveurs, param√®tres ou ex√©cution asynchrone.



## Objectifs## D√©tails techniques

1. Cr√©er endpoint POST /projects/{id}/solve

2. Cr√©er endpoint GET /projects/{id}/solve/status### Fichier √† cr√©er

3. G√©rer r√©solution asynchrone (optionnel)`backend/api/routes/solver.py`

4. Retourner r√©sum√© de r√©solution

5. G√©rer erreurs (aucune solution, timeout, etc.)### Router

```python

## D√©tails techniquesfrom fastapi import APIRouter, Depends, HTTPException, BackgroundTasks

from sqlalchemy.orm import Session

### Sch√©mas Pydantic pour r√©solutionfrom pydantic import BaseModel

from backend.database.engine import get_db

**üìÅ Fichier √† modifier** : `backend/api/schemas.py`from backend.database import models

from backend.services.solver_service import SolverService

**Ajout des sch√©mas** :

router = APIRouter()

```python```

from pydantic import BaseModel

from typing import Optional### Schema Pydantic

```python

# ... Sch√©mas existants (ProjectResponse, MatchResponse, etc.) ...class SolveRequest(BaseModel):

    strategy: str = "cpsat"  # "cpsat" ou "greedy"

# ============================================    

# Sch√©mas R√©solution    class Config:

# ============================================        schema_extra = {

            "example": {

class SolveRequest(BaseModel):                "strategy": "cpsat"

    """            }

    Requ√™te pour r√©soudre un projet.        }

    ```

    Optionnel : override de strat√©gie (si diff√©rente de config YAML).

    """### Endpoint principal

    strategie: Optional[str] = None  # "optimal", "heuristique", "hybride"**`POST /projects/{project_id}/solve`**

    temps_max_secondes: Optional[int] = None  # Override temps_max du YAML

**Param√®tres** :

class SolveResponse(BaseModel):- Path : `project_id: int`

    """- Body : `request: SolveRequest`

    R√©sultat de la r√©solution d'un projet.- Dependencies : `db: Session = Depends(get_db)`

    """

    project_id: int**Impl√©mentation (Option A - Synchrone)** :

    strategie: str```python

    nb_matchs_total: int@router.post("/{project_id}/solve")

    nb_matchs_fixes: intdef solve_project(

    nb_matchs_planifies: int    project_id: int,

    nb_matchs_modifiables: int    request: SolveRequest,

    temps_execution_secondes: float    db: Session = Depends(get_db)

    erreurs: Optional[list[str]] = None):

    """

class SolveStatus(BaseModel):    Lance la r√©solution d'un projet avec la strat√©gie choisie.

    """    

    Statut de r√©solution d'un projet.    Strat√©gies disponibles:

        - cpsat: Optimisation CP-SAT (Google OR-Tools)

    Utilis√© pour r√©solution asynchrone (optionnel).    - greedy: Heuristique gloutonne rapide

    """    """

    project_id: int    

    status: str  # "pending", "running", "completed", "failed"    # V√©rifier projet existe

    progress: Optional[float] = None  # 0.0 √† 1.0    project = db.query(models.Project).filter(models.Project.id == project_id).first()

    message: Optional[str] = None    if not project:

    result: Optional[SolveResponse] = None        raise HTTPException(status_code=404, detail="Projet non trouv√©")

```    

    # Valider strat√©gie

**Points cl√©s** :    if request.strategy not in ["cpsat", "greedy"]:

- **SolveRequest** : Override optionnel de strat√©gie/temps_max        raise HTTPException(

- **SolveResponse** : R√©sum√© complet de r√©solution            status_code=400, 

- **SolveStatus** : Pour r√©solution asynchrone (optionnel)            detail=f"Strat√©gie invalide: {request.strategy}. Utiliser 'cpsat' ou 'greedy'"

        )

---    

    # Instancier service

### Endpoint de r√©solution    service = SolverService(db)

    

**üìÅ Fichier √† cr√©er/modifier** : `backend/api/routes/projects.py`    # R√©soudre

    try:

**Ajout de l'endpoint** :        solution = service.solve_project(project_id, request.strategy)

        

```python        return {

from fastapi import APIRouter, Depends, HTTPException            "message": "R√©solution termin√©e avec succ√®s",

from sqlalchemy.orm import Session            "project_id": project_id,

import time            "strategy": request.strategy,

            "matchs_planifies": len(solution.matchs_planifies),

from backend.database.engine import get_db            "cout_total": solution.cout_total

from backend.api.schemas import SolveRequest, SolveResponse        }

from backend.services.solver_service import SolverService, SolverError    except Exception as e:

        raise HTTPException(status_code=500, detail=f"Erreur r√©solution: {str(e)}")

router = APIRouter()```



# ... Endpoints existants (GET /projects, POST /projects, etc.) ...**Impl√©mentation (Option B - Asynchrone, recommand√©e si solver lent)** :

```python

@router.post("/{project_id}/solve", response_model=SolveResponse)@router.post("/{project_id}/solve")

def solve_project(def solve_project(

    project_id: int,    project_id: int,

    request: SolveRequest = SolveRequest(),  # Body optionnel    request: SolveRequest,

    db: Session = Depends(get_db)    background_tasks: BackgroundTasks,

):    db: Session = Depends(get_db)

    """):

    R√©sout le calendrier d'un projet.    """

        Lance la r√©solution d'un projet en arri√®re-plan.

    **Workflow** :    """

    1. Charge projet depuis DB (config YAML + Excel)    

    2. Ex√©cute solveur selon strat√©gie (config YAML ou override)    # V√©rifications identiques

    3. Met √† jour matchs en DB    project = db.query(models.Project).filter(models.Project.id == project_id).first()

    4. Retourne r√©sum√© de r√©solution    if not project:

            raise HTTPException(status_code=404, detail="Projet non trouv√©")

    **IMPORTANT** :    

    - Respecte les matchs fixes (est_fixe=True)    if request.strategy not in ["cpsat", "greedy"]:

    - Ne modifie que les matchs >= semaine_minimum        raise HTTPException(status_code=400, detail=f"Strat√©gie invalide: {request.strategy}")

    - Strat√©gie depuis config YAML (ou override dans request)    

        # Lancer r√©solution en arri√®re-plan

    **Exemples** :    background_tasks.add_task(

    - `POST /projects/1/solve` : R√©soudre avec strat√©gie du config YAML        _solve_project_background,

    - `POST /projects/1/solve` + body `{"strategie": "heuristique"}` : Override        db,

    """        project_id,

    service = SolverService(db)        request.strategy

        )

    # Override config si fourni dans request    

    if request.strategie or request.temps_max_secondes:    return {

        # TODO: Impl√©menter override (modifier config avant r√©solution)        "message": "R√©solution lanc√©e en arri√®re-plan",

        pass        "project_id": project_id,

            "strategy": request.strategy

    # Mesurer temps d'ex√©cution    }

    start_time = time.time()

    def _solve_project_background(db: Session, project_id: int, strategy: str):

    try:    """Fonction ex√©cut√©e en arri√®re-plan"""

        # Ex√©cuter r√©solution    service = SolverService(db)

        result = service.solve_project(project_id)    try:

                solution = service.solve_project(project_id, strategy)

        # Calculer temps ex√©cution        print(f"‚úÖ R√©solution projet {project_id} termin√©e: {len(solution.matchs_planifies)} matchs")

        temps_execution = time.time() - start_time    except Exception as e:

                print(f"‚ùå Erreur r√©solution projet {project_id}: {e}")

        # Retourner r√©sultat```

        return SolveResponse(

            project_id=result['project_id'],### Inclusion dans l'application

            strategie=result['strategie'],**Modifier** : `backend/api/main.py`

            nb_matchs_total=result['nb_matchs_total'],

            nb_matchs_fixes=result['nb_matchs_fixes'],```python

            nb_matchs_planifies=result['nb_matchs_planifies'],from backend.api.routes import matches, projects, teams, venues, solver

            nb_matchs_modifiables=result['nb_matchs_modifiables'],

            temps_execution_secondes=round(temps_execution, 2),# ...

            erreurs=None

        )app.include_router(solver.router, prefix="/api/projects", tags=["Solver"])

    ```

    except SolverError as e:

        # Erreur m√©tier (aucune solution, contraintes invalides, etc.)### Consignes d'organisation

        raise HTTPException(- Valider la strat√©gie (doit √™tre "cpsat" ou "greedy")

            status_code=400,- V√©rifier que le projet existe (404 si non trouv√©)

            detail=f"Erreur lors de la r√©solution : {str(e)}"- G√©rer les erreurs du solver (500 avec message clair)

        )- Consid√©rer l'ex√©cution asynchrone si le solver est lent (>5s)

    - Logs pour tracking (d√©but/fin r√©solution, dur√©e, erreurs)

    except Exception as e:- En production : ajouter authentification/autorisation si n√©cessaire

        # Erreur inattendue

        raise HTTPException(### Impact et liens

            status_code=500,- Le frontend (`frontend/src/api/endpoints/solver.ts`) appellera cet endpoint.

            detail=f"Erreur serveur : {str(e)}"- Le hook React Query (`frontend/src/hooks/useSolver.ts`) g√©rera l'invalidation du cache.

        )- Le service Solveur (`backend/services/solver_service.py`) sera appel√©.

```

## √Ä faire/v√©rifier

**Points cl√©s** :- Cr√©er le fichier routes/solver.py avec le router

- **POST /projects/{id}/solve** : D√©clenche r√©solution- D√©finir le schema SolveRequest

- **SolveRequest optionnel** : Override strat√©gie/temps_max (body JSON)- Impl√©menter l'endpoint POST /projects/{id}/solve

- **Mesure temps** : time.time() avant/apr√®s r√©solution- Choisir entre ex√©cution synchrone ou asynchrone selon performance

- **Gestion erreurs** : SolverError ‚Üí 400, Exception ‚Üí 500- Inclure le router dans main.py

- Tester l'endpoint :

---  - Backend d√©marr√© : `uvicorn backend.api.main:app --reload`

  - Importer projet : `python scripts/import_excel.py configs/config_volley.yaml "Test"`

### Endpoint de statut (r√©solution asynchrone optionnelle)  - Fixer 2-3 matchs via API : `POST /api/matches/{id}/fix`

  - Lancer r√©solution :

**üìÅ Fichier** : `backend/api/routes/projects.py`    ```bash

    curl -X POST http://localhost:8000/api/projects/1/solve \

**Ajout (optionnel pour r√©solution async)** :      -H "Content-Type: application/json" \

      -d '{"strategy": "cpsat"}'

```python    ```

# Stockage temporaire des statuts (en production, utiliser Redis ou DB)  - V√©rifier r√©ponse 200 avec nombre de matchs planifi√©s

solve_statuses: dict[int, SolveStatus] = {}  - V√©rifier en DB : matchs mis √† jour, fixes inchang√©s

- Tester les erreurs :

@router.get("/{project_id}/solve/status", response_model=SolveStatus)  - Projet inexistant (404)

def get_solve_status(  - Strat√©gie invalide (400)

    project_id: int,  - Erreur solver (500 avec message)

    db: Session = Depends(get_db)- Tester avec strat√©gie "greedy"

):- V√©rifier les logs (d√©but/fin r√©solution, dur√©e)

    """

    R√©cup√®re le statut de r√©solution d'un projet.## Questions

    Poser des questions si des points sur l'ex√©cution asynchrone, la validation, la s√©curit√©, les status codes ou l'int√©gration ne sont pas clairs.

    Utilis√© pour r√©solution asynchrone (optionnel).

    ## Documentation

    **Statuts possibles** :Rester concis, ne pas ajouter de documentation excessive. Utiliser docstrings pour d√©crire l'endpoint et les param√®tres.

    - "pending" : En attente de d√©marrage
    - "running" : En cours d'ex√©cution
    - "completed" : Termin√© avec succ√®s
    - "failed" : √âchec
    """
    status = solve_statuses.get(project_id)
    
    if not status:
        raise HTTPException(
            status_code=404,
            detail=f"Aucune r√©solution en cours pour le projet {project_id}"
        )
    
    return status

@router.delete("/{project_id}/solve", status_code=204)
def cancel_solve(
    project_id: int,
    db: Session = Depends(get_db)
):
    """
    Annule une r√©solution en cours.
    
    **Note** : N√©cessite r√©solution asynchrone avec threading/celery.
    """
    if project_id not in solve_statuses:
        raise HTTPException(
            status_code=404,
            detail=f"Aucune r√©solution en cours pour le projet {project_id}"
        )
    
    # TODO: Impl√©menter annulation (kill thread/task)
    del solve_statuses[project_id]
    
    return None
```

**Points cl√©s** :
- **GET /solve/status** : R√©cup√©rer statut asynchrone
- **DELETE /solve** : Annuler r√©solution en cours
- **solve_statuses** : Dict temporaire (remplacer par Redis/DB en prod)

---

### R√©solution asynchrone avec BackgroundTasks

**üìÅ Fichier** : `backend/api/routes/projects.py`

**Version asynchrone avec FastAPI BackgroundTasks** :

```python
from fastapi import BackgroundTasks

@router.post("/{project_id}/solve", response_model=SolveStatus)
def solve_project_async(
    project_id: int,
    background_tasks: BackgroundTasks,
    request: SolveRequest = SolveRequest(),
    db: Session = Depends(get_db)
):
    """
    R√©sout le calendrier en arri√®re-plan (asynchrone).
    
    Retourne imm√©diatement un statut "pending" et lance la r√©solution en background.
    Utiliser GET /projects/{id}/solve/status pour suivre la progression.
    """
    # Cr√©er statut initial
    status = SolveStatus(
        project_id=project_id,
        status="pending",
        message="R√©solution en attente de d√©marrage"
    )
    solve_statuses[project_id] = status
    
    # Lancer r√©solution en background
    background_tasks.add_task(
        run_solver_background,
        project_id=project_id,
        request=request
    )
    
    return status

def run_solver_background(project_id: int, request: SolveRequest):
    """
    Fonction ex√©cut√©e en arri√®re-plan pour r√©soudre le projet.
    """
    from backend.database.engine import SessionLocal
    
    db = SessionLocal()
    service = SolverService(db)
    
    try:
        # Mettre √† jour statut : running
        solve_statuses[project_id].status = "running"
        solve_statuses[project_id].message = "R√©solution en cours..."
        
        # Ex√©cuter r√©solution
        start_time = time.time()
        result = service.solve_project(project_id)
        temps_execution = time.time() - start_time
        
        # Mettre √† jour statut : completed
        solve_statuses[project_id].status = "completed"
        solve_statuses[project_id].message = "R√©solution termin√©e avec succ√®s"
        solve_statuses[project_id].result = SolveResponse(
            project_id=result['project_id'],
            strategie=result['strategie'],
            nb_matchs_total=result['nb_matchs_total'],
            nb_matchs_fixes=result['nb_matchs_fixes'],
            nb_matchs_planifies=result['nb_matchs_planifies'],
            nb_matchs_modifiables=result['nb_matchs_modifiables'],
            temps_execution_secondes=round(temps_execution, 2),
            erreurs=None
        )
    
    except Exception as e:
        # Mettre √† jour statut : failed
        solve_statuses[project_id].status = "failed"
        solve_statuses[project_id].message = f"Erreur : {str(e)}"
    
    finally:
        db.close()
```

**Points cl√©s** :
- **BackgroundTasks** : FastAPI built-in pour tasks async simples
- **run_solver_background** : Fonction ex√©cut√©e en background
- **Statuts** : pending ‚Üí running ‚Üí completed/failed
- **SessionLocal()** : Nouvelle session DB pour background task

---

### Documentation OpenAPI

**üìÅ Fichier** : `backend/api/routes/projects.py`

**Am√©liorer docstrings pour OpenAPI** :

```python
@router.post("/{project_id}/solve", response_model=SolveResponse, tags=["Solver"])
def solve_project(
    project_id: int,
    request: SolveRequest = SolveRequest(),
    db: Session = Depends(get_db)
):
    """
    R√©sout le calendrier d'un projet avec le solveur configur√©.
    
    ## Workflow
    
    1. **Chargement** : R√©cup√®re projet, matchs, √©quipes, gymnases depuis DB
    2. **Filtrage** : Identifie matchs fixes (est_fixe=True ou semaine < semaine_minimum)
    3. **R√©solution** : Ex√©cute solveur (optimal, heuristique, ou hybride)
    4. **Persistance** : Met √† jour matchs modifiables dans DB
    5. **Validation** : V√©rifie contraintes (matchs fixes, conflits √©quipes/gymnases)
    
    ## Strat√©gies disponibles
    
    - **optimal** : Solveur CP-SAT (OR-Tools) pour solution optimale
    - **heuristique** : Algorithme heuristique rapide
    - **hybride** : Optimal avec fallback heuristique si √©chec/timeout
    
    ## Contraintes respect√©es
    
    - Matchs fixes non modifi√©s (est_fixe=True)
    - Matchs avant semaine_minimum non modifi√©s
    - Respect des indisponibilit√©s (√©quipes, gymnases, institutions)
    - √âquilibre domicile/ext√©rieur
    - Temps de repos entre matchs
    
    ## Exemples
    
    ```bash
    # R√©solution avec strat√©gie du config YAML
    curl -X POST http://localhost:8000/projects/1/solve
    
    # Override strat√©gie
    curl -X POST http://localhost:8000/projects/1/solve \\
      -H "Content-Type: application/json" \\
      -d '{"strategie": "heuristique", "temps_max_secondes": 60}'
    ```
    
    ## R√©ponse
    
    Retourne un r√©sum√© de r√©solution :
    - Strat√©gie utilis√©e
    - Nombre de matchs total, fixes, planifi√©s, modifiables
    - Temps d'ex√©cution
    - Erreurs √©ventuelles
    """
    # ... code existant ...
```

**Points cl√©s** :
- **tags=["Solver"]** : Grouper dans section Solver de OpenAPI
- **Docstring compl√®te** : Workflow, strat√©gies, contraintes, exemples
- **Code blocks** : Exemples curl dans docstring

---

## √Ä faire/v√©rifier

**Checklist de d√©veloppement** :

1. ‚úÖ Cr√©er sch√©mas dans `backend/api/schemas.py` :
   - SolveRequest (strategie, temps_max_secondes optionnels)
   - SolveResponse (r√©sum√© r√©solution)
   - SolveStatus (statut async optionnel)

2. ‚úÖ Cr√©er endpoint dans `backend/api/routes/projects.py` :
   - POST /projects/{id}/solve (r√©solution synchrone)
   - GET /projects/{id}/solve/status (statut async optionnel)
   - DELETE /projects/{id}/solve (annuler async optionnel)

3. ‚úÖ Impl√©menter r√©solution asynchrone (optionnel) :
   - Version BackgroundTasks (simple)
   - Ou version Celery (production)

4. ‚úÖ Am√©liorer documentation OpenAPI :
   - Docstrings compl√®tes
   - Tags pour grouper endpoints
   - Exemples curl

**Checklist de validation** :

1. ‚úÖ **Test endpoint synchrone** :
   ```bash
   # Importer projet
   python scripts/import_excel.py configs/config_volley.yaml
   
   # R√©soudre
   curl -X POST http://localhost:8000/projects/1/solve
   
   # V√©rifier r√©ponse JSON
   # {
   #   "project_id": 1,
   #   "strategie": "optimal",
   #   "nb_matchs_planifies": 45,
   #   ...
   # }
   ```

2. ‚úÖ **Test override strat√©gie** :
   ```bash
   curl -X POST http://localhost:8000/projects/1/solve \
     -H "Content-Type: application/json" \
     -d '{"strategie": "heuristique"}'
   ```

3. ‚úÖ **Test erreurs** :
   ```bash
   # Projet inexistant
   curl -X POST http://localhost:8000/projects/999/solve
   # Doit retourner 404
   
   # Aucun match modifiable (tous fixes)
   # Doit retourner 400 avec message SolverError
   ```

4. ‚úÖ **Test async (si impl√©ment√©)** :
   ```bash
   # Lancer r√©solution async
   curl -X POST http://localhost:8000/projects/1/solve
   # {"status": "pending", ...}
   
   # Polling statut
   curl http://localhost:8000/projects/1/solve/status
   # {"status": "running", "progress": 0.5, ...}
   
   # Attendre completion
   curl http://localhost:8000/projects/1/solve/status
   # {"status": "completed", "result": {...}}
   ```

5. ‚úÖ **Test documentation OpenAPI** :
   ```bash
   # Ouvrir http://localhost:8000/docs
   # V√©rifier section "Solver" avec POST /projects/{id}/solve
   # V√©rifier exemples, sch√©mas, descriptions
   ```

**Commandes de test** :
```bash
# Backend
uvicorn backend.api.main:app --reload

# Test r√©solution
curl -X POST http://localhost:8000/projects/1/solve

# Test avec override
curl -X POST http://localhost:8000/projects/1/solve \
  -H "Content-Type: application/json" \
  -d '{"strategie": "heuristique", "temps_max_secondes": 30}'

# V√©rifier matchs mis √† jour
curl http://localhost:8000/projects/1/matches
```

---

## Questions

**Questions critiques** :

1. **R√©solution synchrone vs asynchrone** :
   - R√©solution synchrone acceptable (blocage quelques secondes) ?
   - Ou r√©solution async obligatoire (temps > 1min) ?
   - Faut-il Celery pour production ou BackgroundTasks suffisant ?

2. **Override config** :
   - Faut-il vraiment permettre override strat√©gie/temps_max ?
   - Ou forcer utilisation config YAML (plus propre) ?
   - Si override, faut-il persister dans DB ou temporaire ?

3. **Gestion erreurs** :
   - Que retourner si aucune solution trouv√©e (400, 404, 500) ?
   - Faut-il des codes d'erreur sp√©cifiques (SOLVER_TIMEOUT, NO_SOLUTION) ?
   - Faut-il rollback DB si validation √©choue apr√®s persist ?

4. **Cache r√©sultats** :
   - Faut-il cacher r√©sultats de r√©solution (√©viter recalcul) ?
   - Invalidation cache : quand ? (apr√®s fix/unfix match, apr√®s import) ?

5. **Notifications** :
   - Faut-il notifier l'utilisateur quand r√©solution async termin√©e ?
   - Websockets, SSE, ou polling simple ?

6. **Logs** :
   - Faut-il logger chaque r√©solution (projet, strat√©gie, temps, r√©sultat) ?
   - Dans fichier, DB, ou service externe (Sentry, Datadog) ?

---

## Documentation

Documenter uniquement :
- **POST /solve** : Expliquer workflow complet (chargement, filtrage, r√©solution, validation)
- **Strat√©gies** : Expliquer diff√©rences optimal/heuristique/hybride
- **Override** : Expliquer SolveRequest pour override temporaire
- **Async** : Expliquer BackgroundTasks vs Celery si impl√©ment√©
