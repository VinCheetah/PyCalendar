#!/usr/bin/env python3
"""
Refactorisation du syst√®me de cr√©neaux pour PyCalendar.

OBJECTIF:
- G√©n√©rer TOUS les cr√©neaux possibles (gymnase √ó horaire √ó semaine)
- Chaque cr√©neau a un statut: libre/occup√© et l'ID du match si occup√©
- Quand un match bouge en JS, lib√©rer l'ancien cr√©neau et occuper le nouveau
"""

import sys
from pathlib import Path

# Lire le fichier Python actuel
transformers_path = Path("data/transformers.py")
visualizer_path = Path("visualization/html_visualizer_v2.py")

print("üîß Refactorisation du syst√®me de cr√©neaux")
print("=" * 60)

# ==================== 1. Modifier data/transformers.py ====================
print("\n1Ô∏è‚É£ Modification de data/transformers.py")
print("-" * 60)

with open(transformers_path, 'r', encoding='utf-8') as f:
    transformers_content = f.read()

# Nouvelle m√©thode pour g√©n√©rer TOUS les cr√©neaux
new_generer_creneaux = '''    @staticmethod
    def generer_creneaux(gymnases: List[Gymnase], nb_semaines: int) -> List[Creneau]:
        """Generate ALL possible time slots (occupied or not).
        
        Changes from previous version:
        - Generates ALL slots (gymnase √ó horaire √ó semaine)
        - Doesn't filter by availability yet (done when assigning matches)
        - Each slot is unique: (semaine, horaire, gymnase)
        
        Returns:
            List of ALL possible time slots
        """
        creneaux = []
        
        for semaine in range(1, nb_semaines + 1):
            for gymnase in gymnases:
                for horaire in gymnase.horaires_disponibles:
                    # Create slot for EVERY combination
                    # Availability check happens during match assignment
                    creneau = Creneau(
                        semaine=semaine,
                        horaire=horaire,
                        gymnase=gymnase.nom
                    )
                    creneaux.append(creneau)
        
        return creneaux'''

# Remplacer l'ancienne m√©thode
old_method_start = transformers_content.find("    @staticmethod\n    def generer_creneaux")
old_method_end = transformers_content.find("        return creneaux", old_method_start) + len("        return creneaux")

if old_method_start != -1:
    transformers_content = (
        transformers_content[:old_method_start] + 
        new_generer_creneaux + 
        transformers_content[old_method_end:]
    )
    
    with open(transformers_path, 'w', encoding='utf-8') as f:
        f.write(transformers_content)
    
    print("‚úÖ generer_creneaux() mis √† jour - g√©n√®re TOUS les cr√©neaux possibles")
else:
    print("‚ùå Impossible de trouver la m√©thode generer_creneaux")
    sys.exit(1)

# ==================== 2. Modifier visualization/html_visualizer_v2.py ====================
print("\n2Ô∏è‚É£ Modification de visualization/html_visualizer_v2.py")
print("-" * 60)

with open(visualizer_path, 'r', encoding='utf-8') as f:
    visualizer_content = f.read()

# Nouvelle m√©thode pour pr√©parer les cr√©neaux avec statut
new_prepare_slots = '''    @staticmethod
    def _prepare_available_slots_data(slots: List[Creneau], matches: List[Match]) -> List[Dict]:
        """Pr√©pare les donn√©es de TOUS les cr√©neaux avec leur statut.
        
        Changement majeur:
        - G√©n√®re TOUS les cr√©neaux (occup√©s et libres)
        - Chaque cr√©neau a: semaine, horaire, gymnase, statut, match_id
        - statut = 'libre' ou 'occup√©'
        - match_id = ID du match si occup√©, null sinon
        
        Args:
            slots: Tous les cr√©neaux possibles (g√©n√©r√©s par generer_creneaux)
            matches: Matchs planifi√©s
            
        Returns:
            Liste de cr√©neaux avec leur statut d'occupation
        """
        # Cr√©er un index des cr√©neaux occup√©s
        occupied_slots = {}
        for match in matches:
            if match.creneau:
                key = f"{match.creneau.semaine}_{match.creneau.horaire}_{match.creneau.gymnase}"
                occupied_slots[key] = match.match_id
        
        # Pr√©parer tous les cr√©neaux avec statut
        data = []
        for slot in slots:
            key = f"{slot.semaine}_{slot.horaire}_{slot.gymnase}"
            
            slot_data = {
                'semaine': slot.semaine,
                'horaire': slot.horaire,
                'gymnase': slot.gymnase,
                'statut': 'occup√©' if key in occupied_slots else 'libre',
                'match_id': occupied_slots.get(key, None),
                'slot_id': key  # ID unique du cr√©neau
            }
            data.append(slot_data)
        
        return data'''

# Remplacer l'ancienne m√©thode _prepare_available_slots_data
old_prepare_start = visualizer_content.find("    @staticmethod\n    def _prepare_available_slots_data")
old_prepare_end = visualizer_content.find("        return data", old_prepare_start) + len("        return data")

if old_prepare_start != -1:
    visualizer_content = (
        visualizer_content[:old_prepare_start] + 
        new_prepare_slots + 
        visualizer_content[old_prepare_end:]
    )
    
    # Mettre √† jour l'appel avec le bon nombre d'arguments
    old_call = "available_slots_data = HTMLVisualizerV2._prepare_available_slots_data(\n            solution.metadata.get('creneaux_disponibles', [])\n        )"
    new_call = "available_slots_data = HTMLVisualizerV2._prepare_available_slots_data(\n            solution.metadata.get('creneaux_disponibles', []),\n            solution.matchs_planifies\n        )"
    
    visualizer_content = visualizer_content.replace(old_call, new_call)
    
    with open(visualizer_path, 'w', encoding='utf-8') as f:
        f.write(visualizer_content)
    
    print("‚úÖ _prepare_available_slots_data() mis √† jour - statut libre/occup√©")
else:
    print("‚ùå Impossible de trouver _prepare_available_slots_data")
    sys.exit(1)

# ==================== 3. Modifier orchestrator/pipeline.py ====================
print("\n3Ô∏è‚É£ Modification de orchestrator/pipeline.py")
print("-" * 60)

pipeline_path = Path("orchestrator/pipeline.py")
with open(pipeline_path, 'r', encoding='utf-8') as f:
    pipeline_content = f.read()

# Remplacer la logique de calcul des cr√©neaux restants
old_creneaux_logic = """        # Calculer les cr√©neaux restants pour passer au visualizer
        creneaux_utilises = {(m.creneau.gymnase, m.creneau.semaine, m.creneau.horaire) 
                            for m in solution.matchs_planifies if m.creneau}
        
        # R√©cup√©rer tous les cr√©neaux depuis les donn√©es
        gymnases = self.source.charger_gymnases()
        tous_creneaux = DataTransformer.generer_creneaux(gymnases, self.config.nb_semaines, self.config.calendar_manager)
        creneaux_restants = [c for c in tous_creneaux 
                            if (c.gymnase, c.semaine, c.horaire) not in creneaux_utilises]
        
        # Stocker dans metadata de la solution
        solution.metadata['creneaux_disponibles'] = creneaux_restants"""

new_creneaux_logic = """        # G√©n√©rer TOUS les cr√©neaux possibles (occup√©s et libres)
        # Le visualizer g√©rera le statut libre/occup√©
        gymnases = self.source.charger_gymnases()
        tous_creneaux = DataTransformer.generer_creneaux(gymnases, self.config.nb_semaines, self.config.calendar_manager)
        
        # Stocker TOUS les cr√©neaux dans metadata (pas seulement les libres)
        solution.metadata['creneaux_disponibles'] = tous_creneaux"""

pipeline_content = pipeline_content.replace(old_creneaux_logic, new_creneaux_logic)

with open(pipeline_path, 'w', encoding='utf-8') as f:
    f.write(pipeline_content)

print("‚úÖ Pipeline mis √† jour - g√©n√®re TOUS les cr√©neaux")

# ==================== 4. Cr√©er le nouveau gestionnaire de cr√©neaux JS ====================
print("\n4Ô∏è‚É£ Cr√©ation de visualization/components/slot-manager.js")
print("-" * 60)

slot_manager_js = '''/**
 * Slot Manager - Gestion des cr√©neaux avec statut libre/occup√©
 * 
 * ARCHITECTURE:
 * - Tous les cr√©neaux (gymnase √ó horaire √ó semaine) sont g√©n√©r√©s au d√©part
 * - Chaque cr√©neau a un statut: 'libre' ou 'occup√©'
 * - Quand un match bouge: lib√©rer ancien cr√©neau + occuper nouveau
 * - Synchronisation avec localStorage pour persistance
 */

class SlotManager {
    constructor(slotsData) {
        // Index des cr√©neaux par slot_id
        this.slots = new Map();
        
        // Initialiser avec les donn√©es
        slotsData.forEach(slot => {
            this.slots.set(slot.slot_id, {
                ...slot,
                statut: slot.statut || 'libre',
                match_id: slot.match_id || null
            });
        });
        
        console.log(`üìã SlotManager initialis√© avec ${this.slots.size} cr√©neaux`);
        this.logStats();
    }
    
    /**
     * Obtenir un cr√©neau par ses coordonn√©es
     */
    getSlot(semaine, horaire, gymnase) {
        const slotId = `${semaine}_${horaire}_${gymnase}`;
        return this.slots.get(slotId);
    }
    
    /**
     * V√©rifier si un cr√©neau est libre
     */
    isSlotFree(semaine, horaire, gymnase) {
        const slot = this.getSlot(semaine, horaire, gymnase);
        return slot && slot.statut === 'libre';
    }
    
    /**
     * Occuper un cr√©neau avec un match
     */
    occupySlot(semaine, horaire, gymnase, matchId) {
        const slotId = `${semaine}_${horaire}_${gymnase}`;
        const slot = this.slots.get(slotId);
        
        if (!slot) {
            console.warn(`‚ö†Ô∏è Cr√©neau inexistant: ${slotId}`);
            return false;
        }
        
        if (slot.statut === 'occup√©' && slot.match_id !== matchId) {
            console.warn(`‚ö†Ô∏è Cr√©neau ${slotId} d√©j√† occup√© par ${slot.match_id}`);
            return false;
        }
        
        slot.statut = 'occup√©';
        slot.match_id = matchId;
        
        console.log(`‚úÖ Cr√©neau ${slotId} occup√© par ${matchId}`);
        return true;
    }
    
    /**
     * Lib√©rer un cr√©neau
     */
    freeSlot(semaine, horaire, gymnase) {
        const slotId = `${semaine}_${horaire}_${gymnase}`;
        const slot = this.slots.get(slotId);
        
        if (!slot) {
            console.warn(`‚ö†Ô∏è Cr√©neau inexistant: ${slotId}`);
            return false;
        }
        
        const previousMatchId = slot.match_id;
        slot.statut = 'libre';
        slot.match_id = null;
        
        console.log(`üÜì Cr√©neau ${slotId} lib√©r√© (√©tait occup√© par ${previousMatchId})`);
        return true;
    }
    
    /**
     * D√©placer un match: lib√©rer ancien cr√©neau + occuper nouveau
     */
    moveMatch(matchId, oldSlot, newSlot) {
        console.log(`üîÑ D√©placement match ${matchId}:`, {
            from: oldSlot,
            to: newSlot
        });
        
        // CONVERSION: week/time/venue ‚Üí semaine/horaire/gymnase
        // Car DataManager utilise {week, time, venue} mais SlotManager attend {semaine, horaire, gymnase}
        const oldSlotConverted = oldSlot ? {
            semaine: oldSlot.week || oldSlot.semaine,
            horaire: oldSlot.time || oldSlot.horaire,
            gymnase: oldSlot.venue || oldSlot.gymnase
        } : null;
        
        const newSlotConverted = {
            semaine: newSlot.week || newSlot.semaine,
            horaire: newSlot.time || newSlot.horaire,
            gymnase: newSlot.venue || newSlot.gymnase
        };
        
        // Lib√©rer ancien cr√©neau
        if (oldSlotConverted) {
            this.freeSlot(oldSlotConverted.semaine, oldSlotConverted.horaire, oldSlotConverted.gymnase);
        }
        
        // Occuper nouveau cr√©neau
        const success = this.occupySlot(
            newSlotConverted.semaine, 
            newSlotConverted.horaire, 
            newSlotConverted.gymnase, 
            matchId
        );
        
        if (success) {
            this.logStats();
            this.saveToLocalStorage();
        }
        
        return success;
    }
    
    /**
     * Obtenir tous les cr√©neaux libres
     */
    getFreeSlots() {
        const freeSlots = [];
        this.slots.forEach(slot => {
            if (slot.statut === 'libre') {
                freeSlots.push(slot);
            }
        });
        return freeSlots;
    }
    
    /**
     * Obtenir tous les cr√©neaux occup√©s
     */
    getOccupiedSlots() {
        const occupiedSlots = [];
        this.slots.forEach(slot => {
            if (slot.statut === 'occup√©') {
                occupiedSlots.push(slot);
            }
        });
        return occupiedSlots;
    }
    
    /**
     * Statistiques des cr√©neaux
     */
    logStats() {
        const free = this.getFreeSlots().length;
        const occupied = this.getOccupiedSlots().length;
        const total = this.slots.size;
        
        console.log(`üìä Cr√©neaux: ${occupied} occup√©s / ${free} libres / ${total} total`);
    }
    
    /**
     * Sauvegarder l'√©tat dans localStorage
     */
    saveToLocalStorage() {
        try {
            const slotsArray = Array.from(this.slots.values());
            localStorage.setItem('slotsState', JSON.stringify(slotsArray));
            console.log('üíæ √âtat des cr√©neaux sauvegard√©');
        } catch (e) {
            console.error('‚ùå Erreur sauvegarde cr√©neaux:', e);
        }
    }
    
    /**
     * Charger l'√©tat depuis localStorage
     */
    loadFromLocalStorage() {
        try {
            const saved = localStorage.getItem('slotsState');
            if (saved) {
                const slotsArray = JSON.parse(saved);
                this.slots.clear();
                
                slotsArray.forEach(slot => {
                    this.slots.set(slot.slot_id, slot);
                });
                
                console.log('üì• √âtat des cr√©neaux charg√© depuis localStorage');
                this.logStats();
                return true;
            }
        } catch (e) {
            console.error('‚ùå Erreur chargement cr√©neaux:', e);
        }
        return false;
    }
    
    /**
     * R√©initialiser tous les cr√©neaux
     */
    reset() {
        this.slots.forEach(slot => {
            slot.statut = 'libre';
            slot.match_id = null;
        });
        
        localStorage.removeItem('slotsState');
        console.log('üîÑ Cr√©neaux r√©initialis√©s');
        this.logStats();
    }
}
'''

slot_manager_path = Path("visualization/components/slot-manager.js")
with open(slot_manager_path, 'w', encoding='utf-8') as f:
    f.write(slot_manager_js)

print("‚úÖ slot-manager.js cr√©√©")

# ==================== R√âSUM√â ====================
print("\n" + "=" * 60)
print("üéâ REFACTORISATION TERMIN√âE")
print("=" * 60)
print("""
‚úÖ Modifications appliqu√©es:

1. data/transformers.py
   ‚Üí generer_creneaux() g√©n√®re TOUS les cr√©neaux possibles

2. visualization/html_visualizer_v2.py
   ‚Üí _prepare_available_slots_data() ajoute statut libre/occup√©
   ‚Üí Chaque cr√©neau a: slot_id, statut, match_id

3. orchestrator/pipeline.py
   ‚Üí G√©n√®re TOUS les cr√©neaux (plus seulement les libres)

4. visualization/components/slot-manager.js (NOUVEAU)
   ‚Üí Gestion des cr√©neaux avec statut
   ‚Üí moveMatch() lib√®re ancien + occupe nouveau
   ‚Üí Synchronisation localStorage

üìù PROCHAINES √âTAPES:

1. Ajouter slot-manager.js dans main.html
2. Int√©grer avec edit-modal.js pour le drag & drop
3. Mettre √† jour conflict-detector.js pour utiliser les cr√©neaux
4. Reg√©n√©rer le calendrier HTML

Commandes:
  python3 orchestrateur_poules.py configs/config_volley.yaml
""")
