/**
 * Vue Grille Horaire - Interface type Google Calendar
 * Affiche les matchs dans une grille horaire avec gymnases en colonnes
 */

class CalendarGridView {
    constructor() {
        this.currentWeek = null;
        this.timeSlotMinutes = 60; // Granularit√© : 30, 60 ou 120 minutes (d√©faut 1h)
        this.startHour = 8;  // Sera calcul√© dynamiquement
        this.endHour = 22;   // Sera calcul√© dynamiquement
        this.matchDuration = 90; // Dur√©e d'un match en minutes
        this.marginMinutes = 30; // Marge avant/apr√®s pour le visuel
    }

    /**
     * Point d'entr√©e principal
     */
    render(container, allMatches, availableSlots, filters, preferences) {
        // Logs de d√©bogage r√©duits (d√©commenter si n√©cessaire pour le debug)
        // console.log('üîµ CalendarGridView.render() - Container:', container ? 'OK' : 'NULL', 'Matches:', allMatches?.length || 0);
        
        // Utiliser timeSlotMinutes depuis preferences
        if (preferences?.timeSlotMinutes) {
            this.timeSlotMinutes = preferences.timeSlotMinutes;
        }
        
        // Validation du container
        if (!container) {
            console.error('‚ùå ERREUR: Container est null ou undefined !');
            return;
        }
        
        // Validation des donn√©es
        if (!allMatches || allMatches.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">üì≠</div>
                    <h3 class="empty-title">Aucun match disponible</h3>
                    <p class="empty-text">Les donn√©es de matchs sont vides ou non charg√©es</p>
                </div>
            `;
            return;
        }
        
        // Initialiser ou conserver la semaine courante
        if (!this.currentWeek || this.currentWeek === null) {
            const weeks = [...new Set(allMatches.map(m => m.semaine))].sort((a, b) => a - b);
            this.currentWeek = weeks[0] || 1;
        }
        
        // Appliquer les filtres
        let filteredMatches = this.applyFilters(allMatches, filters);
        
        // D√©terminer le mode d'affichage bas√© sur les filtres
        const displayMode = this.determineDisplayMode(filters);
        
        // Si un filtre de semaine est actif, synchroniser this.currentWeek
        if (filters.week) {
            this.currentWeek = parseInt(filters.week);
        }
        
        // Filtrer par semaine si mode semaine ET si pas d√©j√† filtr√© par semaine
        let weekMatches, weekSlots;
        if (displayMode === 'week') {
            // Si filters.week existe, les matchs sont d√©j√† filtr√©s, pas besoin de re-filtrer
            if (filters.week) {
                weekMatches = filteredMatches;
                weekSlots = availableSlots ? availableSlots.filter(s => s.semaine == this.currentWeek) : [];
            } else {
                // Sinon, filtrer par currentWeek (navigation normale)
                weekMatches = filteredMatches.filter(m => m.semaine == this.currentWeek);
                weekSlots = availableSlots ? availableSlots.filter(s => s.semaine == this.currentWeek) : [];
            }
        } else {
            weekMatches = filteredMatches;
            weekSlots = availableSlots || [];
        }
        
        // Calculer la plage horaire optimale bas√©e sur les donn√©es r√©elles
        this.calculateTimeRange(weekMatches, weekSlots);
        
        // Obtenir les axes selon le mode d'affichage
        // IMPORTANT: Utiliser allMatches pour les axes, pas weekMatches, pour que la structure reste visible
        const axes = this.getAxes(allMatches, displayMode, filters, this.currentWeek);
        
        if (axes.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">üì≠</div>
                    <h3 class="empty-title">Aucune donn√©e disponible</h3>
                    <p class="empty-text">Les donn√©es de base sont vides</p>
                </div>
            `;
            return;
        }
        
        try {
            // Construire le HTML
            const html = this.buildHTML(allMatches, weekMatches, weekSlots, axes, displayMode, filters, preferences);
            
            // Injecter dans le container
            container.innerHTML = html;
            
            // Attacher les √©v√©nements de navigation
            this.setupEventListeners(container, allMatches, availableSlots, filters, preferences);
            
        } catch (error) {
            console.error('‚ùå ERREUR lors du rendu:', error);
            console.error('Stack trace:', error.stack);
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">‚ö†Ô∏è</div>
                    <h3 class="empty-title">Erreur de rendu</h3>
                    <p class="empty-text">${error.message}</p>
                </div>
            `;
        }
    }
    
    /**
     * Applique les filtres sur les matchs
     */
    applyFilters(matches, filters) {
        let filtered = [...matches];
        
        // Filtre genre
        if (filters.gender) {
            filtered = filtered.filter(m => {
                const gender = Utils.getGender(m);
                // Mapper les filtres M, F, X vers male, female, mixed
                if (filters.gender === 'M') return gender === 'male';
                if (filters.gender === 'F') return gender === 'female';
                if (filters.gender === 'X') return gender === 'mixed';
                return true;
            });
        }
        
        // Filtre institution
        if (filters.institution) {
            filtered = filtered.filter(m => 
                m.institution1 === filters.institution || m.institution2 === filters.institution
            );
        }
        
        // Filtre √©quipe
        if (filters.team) {
            filtered = filtered.filter(m => 
                m.equipe1 === filters.team || m.equipe2 === filters.team
            );
        }
        
        // Filtre poule
        if (filters.pool) {
            filtered = filtered.filter(m => m.poule === filters.pool);
        }
        
        // Filtre gymnase
        if (filters.venue) {
            filtered = filtered.filter(m => m.gymnase === filters.venue);
        }
        
        // Filtre semaine
        if (filters.week) {
            filtered = filtered.filter(m => m.semaine == filters.week);
        }
        
        return filtered;
    }
    
    /**
     * D√©termine le mode d'affichage bas√© sur les filtres actifs
     */
    determineDisplayMode(filters) {
        // Si filtre √©quipe -> afficher toutes les semaines
        if (filters.team) return 'team';
        
        // Si filtre gymnase -> afficher toutes les semaines
        if (filters.venue) return 'venue';
        
        // Si filtre poule -> afficher UNE semaine avec navigation (mode normal)
        // Note: le filtre de poule ne change PAS le mode d'affichage, seulement les donn√©es
        // if (filters.pool) return 'pool';
        
        // Par d√©faut -> afficher une semaine
        return 'week';
    }
    
    /**
     * Obtient les axes selon le mode d'affichage
     * @param {Array} allMatches - Tous les matchs disponibles (pour d√©terminer la structure)
     * @param {String} displayMode - Mode d'affichage actuel
     * @param {Object} filters - Filtres actifs
     * @param {Number} currentWeek - Semaine courante (optionnel)
     */
    getAxes(allMatches, displayMode, filters, currentWeek = null) {
        switch (displayMode) {
            case 'team':
                // Si √©quipe filtr√©e, afficher les semaines en colonnes (toutes les semaines disponibles)
                return [...new Set(allMatches.map(m => m.semaine))].sort((a, b) => a - b);
            
            case 'venue':
                // Si gymnase filtr√©, afficher les semaines en colonnes (toutes les semaines disponibles)
                return [...new Set(allMatches.map(m => m.semaine))].sort((a, b) => a - b);
            
            case 'week':
            default:
                // Par d√©faut, afficher les gymnases en colonnes (tous les gymnases disponibles)
                // Filtrer par semaine courante si n√©cessaire pour obtenir les bons gymnases
                let matchesForAxes = allMatches;
                if (currentWeek && !filters.week) {
                    matchesForAxes = allMatches.filter(m => m.semaine == currentWeek);
                }
                return [...new Set(matchesForAxes.map(m => m.gymnase))].sort();
        }
    }
    
    /**
     * Construit tout le HTML de la vue
     */
    buildHTML(allMatches, weekMatches, weekSlots, axes, displayMode, filters, preferences) {
        const showAvailable = preferences?.showAvailableSlots !== false;
        
        let html = '<div class="calendar-grid-container">';
        
        // Navigation
        html += this.renderNavigationBar(allMatches, displayMode, filters);
        
        // Message d'information si aucun match filtr√©
        if (weekMatches.length === 0) {
            html += `
                <div class="calendar-empty-notice">
                    <div class="empty-notice-content">
                        <span class="empty-notice-icon">‚ÑπÔ∏è</span>
                        <span class="empty-notice-text">Aucun match ne correspond aux filtres actifs pour cette p√©riode. La structure du calendrier reste visible pour la navigation.</span>
                    </div>
                </div>
            `;
        }
        
        // Grille
        html += '<div class="calendar-grid-wrapper">';
        
        // Colonne des heures
        html += this.renderTimeColumn();
        
        // Colonnes selon le mode
        html += '<div class="calendar-venues-container">';
        axes.forEach((axis) => {
            const axisMatches = this.getAxisMatches(weekMatches, axis, displayMode, filters);
            const axisSlots = showAvailable ? this.getAxisSlots(weekSlots, axis, displayMode, filters) : [];
            html += this.renderAxisColumn(axis, axisMatches, axisSlots, displayMode, preferences);
        });
        html += '</div>'; // calendar-venues-container
        
        html += '</div>'; // calendar-grid-wrapper
        html += '</div>'; // calendar-grid-container
        
        return html;
    }
    
    /**
     * Obtient les matchs pour un axe donn√©
     */
    getAxisMatches(matches, axis, displayMode, filters) {
        switch (displayMode) {
            case 'team':
            case 'venue':
                // Axe = semaine
                return matches.filter(m => m.semaine == axis);
            case 'week':
            default:
                // Axe = gymnase
                return matches.filter(m => m.gymnase === axis);
        }
    }
    
    /**
     * Obtient les cr√©neaux disponibles pour un axe donn√©
     */
    getAxisSlots(slots, axis, displayMode, filters) {
        switch (displayMode) {
            case 'team':
            case 'venue':
                // Axe = semaine
                const venue = filters.venue || (slots[0] ? slots[0].gymnase : null);
                return slots.filter(s => s.semaine == axis && (!venue || s.gymnase === venue));
            case 'week':
            default:
                // Axe = gymnase
                return slots.filter(s => s.gymnase === axis);
        }
    }
    
    /**
     * Rendu d'une colonne (remplace renderVenueColumn avec gestion multi-mode)
     */
    renderAxisColumn(axis, matches, availableSlots, displayMode, preferences) {
        const slotHeight = this.getSlotHeight();
        const timeSlots = this.generateTimeSlots();
        
        // D√©terminer le label et l'ic√¥ne selon le mode
        let label, icon, count;
        switch (displayMode) {
            case 'team':
            case 'venue':
                label = `Semaine ${axis}`;
                icon = 'üìÖ';
                break;
            case 'week':
            default:
                label = axis;
                icon = 'üè¢';
                break;
        }
        
        // NOUVEAU: Grouper les matchs par cr√©neau horaire pour g√©rer les matchs simultan√©s
        const matchesBySlot = this.groupMatchesByTimeSlot(matches);
        
        // Calculer le nombre maximum de matchs simultan√©s pour dimensionner la colonne
        const maxSimultaneous = Math.max(1, ...Object.values(matchesBySlot).map(arr => arr.length));
        
        let html = '<div class="calendar-venue-column">';
        
        // En-t√™te
        html += `
            <div class="calendar-venue-header">
                <div class="venue-name">${icon} ${label}</div>
                <div class="venue-count">${matches.length} matchs</div>
            </div>
        `;
        
        // Grille avec lignes horaires de fond
        html += '<div class="calendar-venue-grid">';
        
        // Lignes de fond
        timeSlots.forEach(slot => {
            const cssClass = slot.isHour ? 'hour-mark' : '';
            html += `<div class="calendar-grid-line ${cssClass}" style="height: ${slotHeight}px"></div>`;
        });
        
        // Cr√©neaux disponibles (blocs verts)
        availableSlots.forEach(slot => {
            const pos = this.calculateBlockPosition(slot.horaire, this.matchDuration);
            if (pos) {
                html += `
                    <div class="calendar-available-block" 
                         style="top: ${pos.top}px; height: ${pos.height}px"
                         title="Cr√©neau libre: ${slot.horaire}">
                        ‚úì
                    </div>
                `;
            }
        });
        
        // NOUVEAU: Blocs de matchs avec gestion des sous-colonnes
        Object.keys(matchesBySlot).forEach(timeSlot => {
            const simultaneousMatches = matchesBySlot[timeSlot];
            const count = simultaneousMatches.length;
            
            simultaneousMatches.forEach((match, index) => {
                const pos = this.calculateBlockPosition(match.horaire, this.matchDuration);
                if (pos) {
                    // Ajouter les informations de sous-colonne
                    pos.subColumnIndex = index;
                    pos.subColumnCount = count;
                    html += this.renderMatchBlock(match, pos, displayMode, preferences);
                }
            });
        });
        
        html += '</div>'; // calendar-venue-grid
        html += '</div>'; // calendar-venue-column
        
        return html;
    }
    
    /**
     * Groupe les matchs par cr√©neau horaire pour g√©rer les matchs simultan√©s
     */
    groupMatchesByTimeSlot(matches) {
        const grouped = {};
        
        matches.forEach(match => {
            const key = match.horaire;
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(match);
        });
        
        return grouped;
    }

    /**
     * Calcule la plage horaire optimale bas√©e sur les donn√©es r√©elles
     */
    calculateTimeRange(weekMatches, weekSlots) {
        // R√©cup√©rer tous les horaires (matchs + cr√©neaux disponibles)
        const allTimes = [
            ...weekMatches.map(m => m.horaire),
            ...weekSlots.map(s => s.horaire)
        ].filter(h => h); // Filtrer les valeurs nulles
        
        if (allTimes.length === 0) {
            // Par d√©faut si aucune donn√©e
            this.startHour = 8;
            this.endHour = 22;
            console.log(`‚è∞ Plage horaire par d√©faut: ${this.startHour}h - ${this.endHour}h`);
            return;
        }
        
        // Convertir en minutes
        const allMinutes = allTimes.map(time => Utils.parseTime(time));
        
        // Trouver min et max
        const minMinutes = Math.min(...allMinutes);
        const maxMinutes = Math.max(...allMinutes);
        
        // Ajouter la dur√©e d'un match au max (car le dernier match dure 90 min)
        const maxWithDuration = maxMinutes + this.matchDuration;
        
        // Ajouter des marges pour le confort visuel
        const startWithMargin = minMinutes - this.marginMinutes;
        const endWithMargin = maxWithDuration + this.marginMinutes;
        
        // Arrondir aux heures enti√®res (floor pour le d√©but, ceil pour la fin)
        this.startHour = Math.floor(startWithMargin / 60);
        this.endHour = Math.ceil(endWithMargin / 60);
        
        // Limites de s√©curit√©
        this.startHour = Math.max(6, this.startHour);  // Pas avant 6h
        this.endHour = Math.min(24, this.endHour);     // Pas apr√®s minuit
        
        // Debug: afficher la plage calcul√©e (d√©commenter si n√©cessaire)
        // const minTime = `${Math.floor(minMinutes / 60)}h${String(minMinutes % 60).padStart(2, '0')}`;
        // const maxTime = `${Math.floor(maxMinutes / 60)}h${String(maxMinutes % 60).padStart(2, '0')}`;
        // console.log(`‚è∞ Plage: ${minTime} - ${maxTime} ‚Üí Grille: ${this.startHour}h - ${this.endHour}h`);
    }

    /**
     * Barre de navigation adapt√©e au mode d'affichage
     */
    renderNavigationBar(allMatches, displayMode, filters) {
        // En mode 'week' : navigation par semaine
        // En mode 'team' ou 'venue' : affichage de toutes les semaines d'un coup
        
        let navigationHTML = '';
        let titleHTML = '';
        
        if (displayMode === 'week') {
            // Mode semaine : navigation classique
            const weeks = [...new Set(allMatches.map(m => m.semaine))].sort((a, b) => a - b);
            const minWeek = weeks[0];
            const maxWeek = weeks[weeks.length - 1];
            const canGoPrev = this.currentWeek > minWeek;
            const canGoNext = this.currentWeek < maxWeek;
            
            navigationHTML = `
                <div class="calendar-nav-left">
                    <button class="btn-nav btn-prev-week" ${canGoPrev ? '' : 'disabled'}>
                        ‚Üê Semaine pr√©c√©dente
                    </button>
                    <button class="btn-nav btn-first-week">
                        ‚èÆ Premi√®re
                    </button>
                    <button class="btn-nav btn-next-week" ${canGoNext ? '' : 'disabled'}>
                        Semaine suivante ‚Üí
                    </button>
                </div>
            `;
            
            // Si un filtre de poule est actif, l'afficher dans le titre
            if (filters.pool) {
                titleHTML = `
                    <h2 class="calendar-title">
                        üèÜ ${filters.pool} - Semaine ${this.currentWeek}
                    </h2>
                `;
            } else {
                titleHTML = `
                    <h2 class="calendar-title">
                        üìÖ Semaine ${this.currentWeek}
                    </h2>
                `;
            }
        } else if (displayMode === 'team') {
            // Mode √©quipe : afficher le nom de l'√©quipe
            titleHTML = `
                <h2 class="calendar-title">
                    üë• ${filters.team || '√âquipe'}
                </h2>
            `;
        } else if (displayMode === 'venue') {
            // Mode gymnase : afficher le nom du gymnase
            titleHTML = `
                <h2 class="calendar-title">
                    üè¢ ${filters.venue || 'Gymnase'}
                </h2>
            `;
        }

        return `
            <div class="calendar-nav">
                ${navigationHTML}
                
                <div class="calendar-nav-center">
                    ${titleHTML}
                    <div class="calendar-time-range">
                        ‚è∞ ${this.startHour}h - ${this.endHour}h ‚Ä¢ Zoom: ${this.timeSlotMinutes}min
                    </div>
                </div>
            </div>
        `;
    }
    
    /**
     * Colonne des horaires (fixe √† gauche)
     */
    renderTimeColumn() {
        const slots = this.generateTimeSlots();
        const slotHeight = this.getSlotHeight();
        
        let html = '<div class="calendar-time-column">';
        html += '<div class="calendar-time-header">Horaire</div>';
        
        slots.forEach(slot => {
            html += `<div class="calendar-time-slot" style="height: ${slotHeight}px">${slot.label}</div>`;
        });
        
        html += '</div>';
        return html;
    }

    /**
     * Bloc de match avec pr√©f√©rences d'affichage
     */
    renderMatchBlock(match, pos, displayMode = 'week', preferences = {}) {
        const gender = Utils.getGender(match);
        const colorClass = gender === 'M' || gender === 'male' ? 'male' : gender === 'F' || gender === 'female' ? 'female' : 'mixed';
        
        // Pour la vue grille : genre TOUJOURS affich√©, institution JAMAIS affich√©e
        
        // D√©terminer le niveau de d√©tail selon la hauteur r√©elle calcul√©e
        // Hauteurs r√©elles: 30min‚Üí180px, 60min‚Üí120px, 120min‚Üí45px
        const height = pos.height;
        const detailLevel = height < 70 ? 'minimal' : height < 150 ? 'compact' : 'full';
        
        // Ic√¥ne genre (toujours utilis√©)
        const genderIcon = colorClass === 'male' ? '‚ôÇ' : colorClass === 'female' ? '‚ôÄ' : '‚ö•';
        
        // Raccourcir intelligemment selon le niveau de d√©tail
        let team1, team2;
        if (detailLevel === 'minimal') {
            team1 = match.equipe1.length > 14 ? match.equipe1.substring(0, 12) + '.' : match.equipe1;
            team2 = match.equipe2.length > 14 ? match.equipe2.substring(0, 12) + '.' : match.equipe2;
        } else if (detailLevel === 'compact') {
            team1 = match.equipe1.length > 18 ? match.equipe1.substring(0, 16) + '.' : match.equipe1;
            team2 = match.equipe2.length > 18 ? match.equipe2.substring(0, 16) + '.' : match.equipe2;
        } else {
            team1 = match.equipe1.length > 22 ? match.equipe1.substring(0, 20) + '.' : match.equipe1;
            team2 = match.equipe2.length > 22 ? match.equipe2.substring(0, 20) + '.' : match.equipe2;
        }
        
        // Tooltip enrichi
        const tooltipParts = [
            `${match.equipe1} vs ${match.equipe2}`,
            match.horaire ? `‚è∞ ${match.horaire}` : '',
            match.poule ? `üèÜ ${match.poule}` : '',
            match.gymnase ? `üìç ${match.gymnase}` : '',
            match.institution1 && match.institution2 ? `üèõÔ∏è ${match.institution1} vs ${match.institution2}` : ''
        ].filter(p => p).join('\n');
        
        // === RENDU MINIMAL (cr√©neaux < 80px - granularit√© 30min) ===
        if (detailLevel === 'minimal') {
            return `
                <div class="calendar-match-block calendar-match-${colorClass} detail-minimal" 
                     style="top: ${pos.top}px; height: ${pos.height}px"
                     title="${tooltipParts}">
                    <div class="grid-minimal-header">
                        <span class="grid-minimal-time">${match.horaire}</span>
                        <span class="grid-minimal-gender">${genderIcon}</span>
                    </div>
                    <div class="grid-minimal-teams">
                        <div class="grid-minimal-team">${team1}</div>
                        <div class="grid-minimal-vs">VS</div>
                        <div class="grid-minimal-team">${team2}</div>
                    </div>
                </div>
            `;
        }
        
        // === RENDU COMPACT (cr√©neaux 80-120px - granularit√© 60min) ===
        if (detailLevel === 'compact') {
            return `
                <div class="calendar-match-block calendar-match-${colorClass} detail-compact" 
                     style="top: ${pos.top}px; height: ${pos.height}px"
                     title="${tooltipParts}">
                    <div class="grid-compact-header">
                        <span class="grid-compact-time">${match.horaire}</span>
                        <span class="grid-compact-gender">${genderIcon}</span>
                    </div>
                    <div class="grid-compact-teams">
                        <div class="grid-compact-team">${team1}</div>
                        <div class="grid-compact-vs">VS</div>
                        <div class="grid-compact-team">${team2}</div>
                    </div>
                </div>
            `;
        }
        
        // === RENDU COMPLET (cr√©neaux > 120px) ===
        // Genre toujours affich√© dans la grille
        const genderBadge = `<span class="badge-gender badge-gender-${colorClass}">${genderIcon}</span>`;
        
        // Info contextuelle (poule ou gymnase - JAMAIS les institutions)
        let contextInfo = '';
        if (displayMode === 'team' || displayMode === 'venue') {
            if (match.gymnase) {
                const gymShort = match.gymnase.length > 14 ? match.gymnase.substring(0, 12) + '.' : match.gymnase;
                contextInfo = `<div class="grid-context-info">üìç ${gymShort}</div>`;
            }
        } else {
            if (match.poule) {
                const pouleShort = match.poule.length > 14 ? match.poule.substring(0, 12) + '.' : match.poule;
                contextInfo = `<div class="grid-context-info">ÔøΩ ${pouleShort}</div>`;
            }
        }
        
        return `
            <div class="calendar-match-block calendar-match-${colorClass} detail-full" 
                 style="top: ${pos.top}px; height: ${pos.height}px"
                 title="${tooltipParts}">
                <div class="grid-header-full">
                    <span class="grid-time-full">${match.horaire}</span>
                    ${genderBadge}
                </div>
                <div class="grid-teams-full">
                    <div class="grid-team-full">${team1}</div>
                    <div class="grid-vs-full">VS</div>
                    <div class="grid-team-full">${team2}</div>
                </div>
                ${contextInfo}
            </div>
        `;
    }

    /**
     * G√©n√®re les cr√©neaux horaires
     */
    generateTimeSlots() {
        const slots = [];
        const totalMinutes = (this.endHour - this.startHour) * 60;
        
        for (let offset = 0; offset < totalMinutes; offset += this.timeSlotMinutes) {
            const totalMins = this.startHour * 60 + offset;
            const hour = Math.floor(totalMins / 60);
            const minute = totalMins % 60;
            
            slots.push({
                label: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`,
                minutes: totalMins,
                isHour: minute === 0
            });
        }
        
        return slots;
    }

    /**
     * Calcule position et hauteur d'un bloc
     */
    calculateBlockPosition(timeStr, durationMinutes) {
        const matchMinutes = Utils.parseTime(timeStr);
        const gridStartMinutes = this.startHour * 60;
        const gridEndMinutes = this.endHour * 60;
        
        // V√©rifier si dans la plage (silencieux si hors plage - comportement normal)
        if (matchMinutes < gridStartMinutes || matchMinutes >= gridEndMinutes) {
            return null;
        }
        
        const offsetMinutes = matchMinutes - gridStartMinutes;
        const pixelsPerMinute = this.getSlotHeight() / this.timeSlotMinutes;
        
        return {
            top: offsetMinutes * pixelsPerMinute,
            height: durationMinutes * pixelsPerMinute
        };
    }

    /**
     * Hauteur d'un cr√©neau en pixels
     * Calcule dynamiquement pour que la grille ne n√©cessite jamais de scroll vertical
     */
    getSlotHeight() {
        // Calculer la hauteur disponible pour la grille
        // Hauteur fen√™tre - (header app + title/stats ~150px + controls section ~180px + nav calendrier ~95px + header grille ~60px + padding/marges ~80px)
        const fixedElementsHeight = 565;
        const availableHeight = window.innerHeight - fixedElementsHeight;
        
        // Calculer le nombre total de cr√©neaux
        const totalMinutes = (this.endHour - this.startHour) * 60;
        const totalSlots = totalMinutes / this.timeSlotMinutes;
        
        // Calculer la hauteur optimale par cr√©neau
        const calculatedHeight = Math.floor(availableHeight / totalSlots);
        
        // D√©finir des hauteurs minimales par granularit√© pour garder la lisibilit√©
        const minHeights = {
            30: 35,  // Au moins 35px pour 30min
            60: 45,  // Au moins 45px pour 60min
            120: 30  // Au moins 30px pour 120min
        };
        
        const minHeight = minHeights[this.timeSlotMinutes] || 45;
        
        // Retourner le maximum entre la hauteur calcul√©e et la hauteur minimale
        const finalHeight = Math.max(calculatedHeight, minHeight);
        
        return finalHeight;
    }

    /**
     * Configure les √©v√©nements
     */
    setupEventListeners(container, allMatches, availableSlots, filters, preferences) {
        const weeks = [...new Set(allMatches.map(m => m.semaine))].sort((a, b) => a - b);
        
        // Bouton semaine pr√©c√©dente
        const btnPrev = container.querySelector('.btn-prev-week');
        if (btnPrev) {
            btnPrev.addEventListener('click', () => {
                const idx = weeks.indexOf(this.currentWeek);
                if (idx > 0) {
                    this.currentWeek = weeks[idx - 1];
                    this.render(container, allMatches, availableSlots, filters, preferences);
                }
            });
        }
        
        // Bouton semaine suivante
        const btnNext = container.querySelector('.btn-next-week');
        if (btnNext) {
            btnNext.addEventListener('click', () => {
                const idx = weeks.indexOf(this.currentWeek);
                if (idx < weeks.length - 1) {
                    this.currentWeek = weeks[idx + 1];
                    this.render(container, allMatches, availableSlots, filters, preferences);
                }
            });
        }
        
        // Bouton premi√®re semaine
        const btnFirst = container.querySelector('.btn-first-week');
        if (btnFirst) {
            btnFirst.addEventListener('click', () => {
                this.currentWeek = weeks[0];
                this.render(container, allMatches, availableSlots, filters, preferences);
            });
        }
    }
}
